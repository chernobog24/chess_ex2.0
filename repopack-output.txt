<summary>

<header>
Repopack Output File
This file was generated by Repopack on: 2024-10-11T00:00:56.972Z
</header>

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository structure
3. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the file path attributes to distinguish
  between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.


</notes>

<additional_info>
For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</summary>

<repository_structure>
background/service-worker.js
manifest.json
overlay/overlay.js
popup/popup.css
popup/popup.html
popup/popup.js
README.md
scripts/chess-game.js
scripts/puzzle-generator.js
settings/settings.css
settings/settings.html
settings/settings.js
</repository_structure>

<repository_files>

<file path="background/service-worker.js">
let websiteTimers = {};
let settings = {
  websites: [],
  timerDuration: 30 // Default 30 minutes
};

chrome.runtime.onInstalled.addListener(() => {
  chrome.storage.sync.get(['websites', 'timerDuration'], (data) => {
    if (data.websites) settings.websites = data.websites;
    if (data.timerDuration) settings.timerDuration = data.timerDuration;
  });
});

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (changeInfo.status === 'complete' && tab.url) {
    const website = settings.websites.find(site => tab.url.includes(site));
    if (website) {
      startTimer(tabId, website);
    }
  }
});

function startTimer(tabId, website) {
  if (websiteTimers[tabId]) {
    clearTimeout(websiteTimers[tabId]);
  }
  websiteTimers[tabId] = setTimeout(() => {
    chrome.tabs.sendMessage(tabId, { action: "showOverlay" });
  }, settings.timerDuration * 60 * 1000);
}

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  switch (request.action) {
    case "getTimerStatus":
      if (sender.tab) {
        const remainingTime = getTimerStatus(sender.tab.id);
        sendResponse({ status: `Time remaining: ${remainingTime} minutes` });
      } else {
        sendResponse({ status: "No active timer" });
      }
      break;
    case "overlayCompleted":
      if (request.solved) {
        resetTimer(sender.tab.id);
      }
      break;
    case "updateSettings":
      updateSettings(request.settings);
      break;
  }
  return true; // Required for sendResponse to work
});

function getTimerStatus(tabId) {
  if (!websiteTimers[tabId]) return 0;
  const elapsed = Date.now() - websiteTimers[tabId].startTime;
  return Math.max(0, Math.round((settings.timerDuration * 60 * 1000 - elapsed) / (60 * 1000)));
}

function resetTimer(tabId) {
  if (websiteTimers[tabId]) {
    clearTimeout(websiteTimers[tabId]);
    delete websiteTimers[tabId];
  }
}

function updateSettings(newSettings) {
  settings = { ...settings, ...newSettings };
  chrome.storage.sync.set(settings);
  // Optionally reset all timers here if settings have changed significantly
}

// Listen for tab removal to clean up timers
chrome.tabs.onRemoved.addListener((tabId) => {
  if (websiteTimers[tabId]) {
    clearTimeout(websiteTimers[tabId]);
    delete websiteTimers[tabId];
  }
});
</file>

<file path="manifest.json">
{
    "manifest_version": 3,
    "name": "Chessboard Popup",
    "version": "2.0",
    "description": "Chess puzzles and timed website breaks with interactive chessboard",
    "icons": {
      "16": "images/icon-16.png",
      "32": "images/icon-32.png",
      "48": "images/icon-48.png",
      "128": "images/icon-128.png"
    },
    "action": {
      "default_popup": "popup/popup.html",
      "default_icon": {
        "16": "images/icon-16.png",
        "32": "images/icon-32.png",
        "48": "images/icon-48.png",
        "128": "images/icon-128.png"
      }
    },
    "permissions": [
      "storage",
      "alarms",
      "activeTab",
      "tabs"
    ],
    "host_permissions": [
      "*://blank.org/*"
    ],
    "background": {
      "service_worker": "background/service-worker.js"
    },
    "options_page": "settings/settings.html",
    "content_scripts": [
      {
        "matches": ["*://blank.org/*"],
        "js": [
          "libs/jquery.min.js",
          "libs/chessboardjs-1.0.0/js/chessboard-1.0.0.min.js",
          "libs/chess.js",
          "scripts/chess-game.js",
          "scripts/puzzle-generator.js",
          "scripts/timer.js",
          "overlay/overlay.js"
        ],
        "css": [
          "libs/chessboardjs-1.0.0/css/chessboard-1.0.0.min.css",
          "styles/chessboard.css"
        ]
      }
    ],
    "web_accessible_resources": [
      {
        "resources": [
          "libs/chessboardjs-1.0.0/img/chesspieces/wikipedia/*",
          "Puzzles/puzzles.json",
          "overlay/overlay.html",
          "images/solved.webm",
          "overlay/overlay.css"
        ],
        "run_at": "document_end",
        "matches": ["*://blank.org/*"]
      }
    ]
  }
</file>

<file path="overlay/overlay.js">
console.log("Overlay script loaded");

class ChessPuzzleOverlay {
  constructor() {
    this.chessGame = null;
    this.puzzleGenerator = null;
    this.timer = null;
    this.puzzleSolved = false;
    this.solvedAnimationUrl = chrome.runtime.getURL('images/solved.webm');
  }

  injectOverlay() {
    console.log("Injecting overlay");
    const overlayHTML = `
    <style>
      #chessOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      #puzzleContainer {
        background: white;
        padding: 20px;
        border-radius: 10px;
      }
      #chessboard {
        width: 600px;
        height: 600px;
      }
      #puzzleInfo {
        text-align: center;
        margin-top: 20px;
      }
      #closeOverlay {
        margin-top: 10px;
      }
      .piece-417db {
        z-index: 10000 !important;
      }
      .highlight-green {
        box-shadow: inset 0 0 3px 3px green;
      }
      .highlight-move {
        background-color: rgba(255, 255, 0, 0.5) !important;
      }
      .highlight-square::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 25%;
        height: 25%;
        background-color: rgba(10, 128, 10, 0.5);
        border-radius: 50%;
        z-index: 10;
      }
      #solvedAnimation {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10001;
        display: none;
        width: 100px;  /* Adjust this value to make it bigger or smaller */
        height: auto;  /* This maintains the aspect ratio */
      }
    </style>
    <div id="chessOverlay">
      <div id="puzzleContainer">
        <div id="chessboard"></div>
        <div id="puzzleInfo">
          <p id="puzzlePrompt">Solve the puzzle to continue browsing</p>
          <p id="timerDisplay"></p>
        </div>
      </div>
      <button id="closeOverlay" disabled>Close</button>
      <video id="solvedAnimation" src="${this.solvedAnimationUrl}" muted></video>
    </div>
    `;
    document.body.insertAdjacentHTML('beforeend', overlayHTML);
  }

  initializeOverlay() {
    this.chessGame = new ChessGame('chessboard', {
      boardId: 'chessboard',
      onMove: this.onMove.bind(this),
      onPuzzleSolved: this.onPuzzleSolved.bind(this)
    });
    this.chessGame.init();
    this.puzzleGenerator = new PuzzleGenerator();
    document.getElementById('closeOverlay').addEventListener('click', this.closeOverlay.bind(this));
  }

  onMove(move) {
    // This method can be used for any additional logic needed after a move
    // The correctness of the move is now handled in the ChessGame class
  }

  onPuzzleSolved() {
    this.endPuzzle(true);
    this.playSolvedAnimation();
  }

  playSolvedAnimation() {
    const video = document.getElementById('solvedAnimation');
    video.style.display = 'block';
    video.currentTime = 0;  // Reset to the beginning
    video.play().then(() => {
      video.onended = () => {
        video.style.display = 'none';
      };
    }).catch(error => {
      console.error('Error playing video:', error);
      video.style.display = 'none';
    });
  }

  showOverlay() {
    this.injectOverlay();
    this.initializeOverlay();
    document.getElementById('chessOverlay').style.display = 'flex';
    this.loadNewPuzzle();
    this.startTimer();
  }

  async loadNewPuzzle() {
    try {
      const puzzle = await this.puzzleGenerator.getRandomPuzzle();
      this.chessGame.setPuzzle(puzzle.fen, puzzle.moves);
      this.puzzleSolved = false;
      this.updatePuzzleInfo(puzzle);
    } catch (error) {
      console.error('Error loading puzzle:', error);
      // Handle the error appropriately (e.g., show a message to the user)
    }
  }

  updatePuzzleInfo(puzzle) {
    const difficulty = this.puzzleGenerator.getCurrentPuzzleDifficulty();
    document.getElementById('puzzlePrompt').textContent = `Solve this ${difficulty} puzzle to continue browsing`;
  }

  startTimer() {
    let timeLeft = 300; // 5 minutes
    this.timer = setInterval(() => {
      timeLeft--;
      document.getElementById('timerDisplay').textContent = `Time left: ${timeLeft}s`;
      if (timeLeft <= 0) {
        this.endPuzzle(false);
      }
    }, 1825);
  }

  endPuzzle(solved) {
    clearInterval(this.timer);
    this.puzzleSolved = solved;
    document.getElementById('closeOverlay').disabled = false;
    document.getElementById('puzzlePrompt').textContent = solved ? 'Puzzle solved! You can close the overlay.' : 'Time\'s up! You can close the overlay.';
    if (solved) {
      this.playSolvedAnimation();
    }
  }

  closeOverlay() {
    if (this.puzzleSolved || document.getElementById('closeOverlay').disabled === false) {
      document.getElementById('chessOverlay').style.display = 'none';
      chrome.runtime.sendMessage({action: "overlayCompleted", solved: this.puzzleSolved});
    }
  }

  getHint() {
    return this.puzzleGenerator.getHint();
  }
}

let chessPuzzleOverlay = null;

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log("Received message:", request);
  if (request.action === "showOverlay") {
    if (!chessPuzzleOverlay) {
      chessPuzzleOverlay = new ChessPuzzleOverlay();
    }
    chessPuzzleOverlay.showOverlay();
  }
});

console.log("Overlay script ready");
</file>

<file path="popup/popup.css">
body {
    width: 200px;
    padding: 10px;
  }
  
  button {
    width: 100%;
    margin: 5px 0;
    padding: 5px;
  }
  
  #timerStatus {
    margin-top: 10px;
    text-align: center;
  }
</file>

<file path="popup/popup.html">
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="popup.css">
</head>
<body>
  <h1>Chessboard Popup</h1>
  <button id="settingsBtn">Settings</button>
  <button id="triggerOverlayBtn">Show Chess Puzzle</button>
  <div id="timerStatus"></div>
  <script src="popup.js"></script>
</body>
</html>
</file>

<file path="popup/popup.js">
document.getElementById('settingsBtn').addEventListener('click', () => {
    chrome.runtime.openOptionsPage();
  });
  
  document.getElementById('triggerOverlayBtn').addEventListener('click', () => {
    chrome.tabs.query({active: true, currentWindow: true}, (tabs) => {
      chrome.tabs.sendMessage(tabs[0].id, {action: "showOverlay"});
    });
  });
  
  // Fetch and display timer status
  chrome.runtime.sendMessage({action: "getTimerStatus"}, (response) => {
    document.getElementById('timerStatus').textContent = response.status;
  });
</file>

<file path="README.md">
# Chess Puzzle Extension

This is a Chrome extension for solving chess puzzles. It provides an interactive chess board interface where users can practice and improve their chess skills by solving various puzzles.

## Project Structure

- `manifest.json`: The extension manifest file
- `background/`: Contains the service worker for the extension
- `images/`: Icon images for the extension
- `overlay/`: Contains the overlay JavaScript file
- `popup/`: Contains the popup HTML, CSS, and JavaScript files
- `scripts/`: Contains the main chess game and puzzle generator scripts
- `settings/`: Contains the settings HTML, CSS, and JavaScript files
- `styles/`: Contains the chessboard CSS file

## Libraries

The `libs/` directory is not included in this repository. You need to obtain the following libraries:

- chess.js
- jquery.min.js
- chessboard.js (version 1.0.0)

Place these files in the `libs/` directory.

## Puzzles

The `Puzzles/` directory is not included in this repository. To get the puzzles:

1. Download the puzzle database from Lichess: [Lichess Puzzle Database](https://database.lichess.org/#puzzles)
2. Format the puzzles according to the Lichess puzzle format
3. Use the `puzzleutils.py` script to process and prepare the puzzles for use in the extension

## Setup

1. Clone this repository
2. Obtain the required libraries and place them in the `libs/` directory
3. Prepare the puzzles and place them in the `Puzzles/` directory
4. Load the extension in Chrome:
   - Go to `chrome://extensions/`
   - Enable "Developer mode"
   - Click "Load unpacked"
   - Select the directory containing this project

## Usage

After loading the extension, click on the extension icon in Chrome to open the popup and start solving chess puzzles.
</file>

<file path="scripts/chess-game.js">
class ChessGame {
  constructor(boardId, config = {}) {
    this.game = new Chess();
    this.boardConfig = {
      draggable: true,
      dropOffBoard: 'snapback',
      position: 'start',
      onDragStart: this.onDragStart.bind(this),
      onDrop: this.onDrop.bind(this),
      onSnapEnd: this.onSnapEnd.bind(this),
      onMouseoutSquare: this.onMouseoutSquare.bind(this),
      onMouseoverSquare: this.onMouseoverSquare.bind(this),
      pieceTheme: function(piece) {
        return chrome.runtime.getURL('libs/chessboardjs-1.0.0/img/chesspieces/wikipedia/' + piece + '.png');
      },
      ...config
    };
    this.board = null;
    this.onMoveCallback = config.onMove || (() => {});
    this.onPuzzleSolvedCallback = config.onPuzzleSolved || (() => {});
    this.puzzleMoves = [];
    this.currentMoveIndex = 0;
  }

  init() {
    this.board = Chessboard(this.boardConfig.boardId, this.boardConfig);
  }

  setPuzzle(fen, moves) {
    this.game.load(fen);
    this.board.position(fen);
    this.puzzleMoves = moves;
    this.currentMoveIndex = 0;
    this.makeNextMove(); // Make the initial opponent move
  }

  onDragStart(source, piece) {
    if (this.game.game_over() || this.isPuzzleSolved()) return false;
    if ((this.game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (this.game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
  }

  onDrop(source, target) {
    const move = this.game.move({
      from: source,
      to: target,
      promotion: 'q'
    });
    
    if (move === null) return 'snapback';

    if (this.isCorrectMove(move)) {
      this.removeHighlights();
      this.highlightMove(move);
      this.currentMoveIndex++;
      this.onMoveCallback(move);
      
      if (!this.isPuzzleSolved()) {
        setTimeout(() => this.makeNextMove(), 300);
      } else {
        this.onPuzzleSolvedCallback();
      }
      
      return move;
    } else {
      this.game.undo();
      return 'snapback';
    }
  }

  onSnapEnd() {
    this.board.position(this.game.fen());
  }

  onMouseoverSquare(square) {
    if (this.isPuzzleSolved()) return;
    const moves = this.game.moves({ square: square, verbose: true });
    if (moves.length === 0) return;

    moves.forEach(move => this.highlightSquare(move.to));
  }

  onMouseoutSquare() {
    this.removeHighlights();
  }

  isCorrectMove(move) {
    const expectedMove = this.puzzleMoves[this.currentMoveIndex];
    return move.from + move.to === expectedMove;
  }

  makeNextMove() {
    if (this.isPuzzleSolved()) return;

    const move = this.puzzleMoves[this.currentMoveIndex];
    const result = this.game.move({
      from: move.slice(0, 2),
      to: move.slice(2, 4),
      promotion: 'q'
    });

    this.board.position(this.game.fen(), true); // Animate the move
    this.highlightMove(result);
    this.currentMoveIndex++;

    if (this.isPuzzleSolved()) {
      this.onPuzzleSolvedCallback();
    }
  }

  isPuzzleSolved() {
    return this.currentMoveIndex >= this.puzzleMoves.length;
  }

  highlightSquare(square) {
    $(`#${this.boardConfig.boardId} .square-${square}`).addClass('highlight-square');
  }

  removeHighlights() {
    $(`#${this.boardConfig.boardId} .square-55d63`).removeClass('highlight-square');
  }

  removeMoveHighlights() {
    $(`#${this.boardConfig.boardId} .square-55d63`).removeClass('highlight-move');
  }

  highlightMove(move) {
    this.removeMoveHighlights();
    $(`#${this.boardConfig.boardId} .square-${move.from}`).addClass('highlight-move');
    $(`#${this.boardConfig.boardId} .square-${move.to}`).addClass('highlight-move');
  }

  setPosition(fen) {
    this.game.load(fen);
    this.board.position(fen);
  }

  reset() {
    this.game.reset();
    this.board.start();
    this.puzzleMoves = [];
    this.currentMoveIndex = 0;
  }
}

window.ChessGame = ChessGame;
</file>

<file path="scripts/puzzle-generator.js">
class PuzzleGenerator {
  constructor() {
    this.puzzles = [];
    this.currentPuzzle = null;
    this.usedPuzzles = new Set();
    this.loaded = false;

    this.loadPuzzles();
  }

  loadPuzzles() {
    return fetch(chrome.runtime.getURL('Puzzles/puzzles.json'))
      .then(response => response.json())
      .then(data => {
        this.puzzles = data;
        this.loaded = true;
        console.log('Puzzles loaded:', this.puzzles.length);
      })
      .catch(err => {
        console.error('Failed to load puzzles:', err);
        this.loaded = false;
      });
  }

  async getRandomPuzzle() {
    if (!this.loaded) {
      await this.loadPuzzles();
    }

    console.log('Puzzles available:', this.puzzles.length);
    if (this.puzzles.length === 0) {
      this.resetPuzzles();
    }

    if (this.puzzles.length === 0) {
      throw new Error('No puzzles available');
    }

    const index = Math.floor(Math.random() * this.puzzles.length);
    this.currentPuzzle = this.puzzles.splice(index, 1)[0];
    this.usedPuzzles.add(this.currentPuzzle);
    console.log('Current puzzle:', this.currentPuzzle);
    console.log('Moves:', this.currentPuzzle.Moves);
    return {
      fen: this.currentPuzzle.FEN,
      moves: this.currentPuzzle.Moves.split(' '),
      tags: this.currentPuzzle.Themes.split(' ')
    };
  }

  resetPuzzles() {
    this.puzzles = [...this.usedPuzzles];
    this.usedPuzzles.clear();
  }

  checkSolution(moves) {
    if (!this.currentPuzzle) return false;

    const solutionMoves = this.currentPuzzle.Moves.split(' ');
    return moves.join(' ') === solutionMoves.join(' ');
  }

  getCurrentPuzzleDifficulty() {
    if (!this.currentPuzzle) return null;

    const rating = this.currentPuzzle.Rating;
    if (rating >= 2000) return 'Hard';
    if (rating >= 1500) return 'Medium';
    return 'Easy';
  }

  getHint() {
    if (!this.currentPuzzle) return null;

    const firstMove = this.currentPuzzle.Moves.split(' ')[0];
    return `Try moving from ${firstMove.slice(0, 2)} to ${firstMove.slice(2, 4)}`;
  }
}

window.PuzzleGenerator = PuzzleGenerator;
</file>

<file path="settings/settings.css">
body {
    width: 300px;
    padding: 20px;
  }
  
  input, button {
    margin: 5px 0;
    padding: 5px;
  }
  
  #websiteList {
    max-height: 200px;
    overflow-y: auto;
  }
  
  #timerSetting {
    margin: 20px 0;
  }
</file>

<file path="settings/settings.html">
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="settings.css">
</head>
<body>
  <h1>Settings</h1>
  <div id="websiteManager">
    <input type="text" id="websiteInput" placeholder="Enter website URL">
    <button id="addWebsite">Add</button>
    <ul id="websiteList"></ul>
  </div>
  <div id="timerSetting">
    <label for="timerDuration">Timer Duration (minutes):</label>
    <input type="number" id="timerDuration" min="1" max="120">
  </div>
  <button id="saveSettings">Save</button>
  <button id="resetSettings">Reset to Default</button>
  <script src="settings.js"></script>
</body>
</html>
</file>

<file path="settings/settings.js">
document.addEventListener('DOMContentLoaded', loadSettings);
document.getElementById('addWebsite').addEventListener('click', addWebsite);
document.getElementById('saveSettings').addEventListener('click', saveSettings);
document.getElementById('resetSettings').addEventListener('click', resetSettings);

function loadSettings() {
  chrome.storage.sync.get(['websites', 'timerDuration'], (data) => {
    if (data.websites) updateWebsiteList(data.websites);
    if (data.timerDuration) document.getElementById('timerDuration').value = data.timerDuration;
  });
}

function addWebsite() {
  const input = document.getElementById('websiteInput');
  const website = input.value.trim();
  if (website) {
    chrome.storage.sync.get({websites: []}, (data) => {
      if (!data.websites.includes(website)) {
        data.websites.push(website);
        chrome.storage.sync.set({websites: data.websites}, () => {
          updateWebsiteList(data.websites);
          input.value = '';
        });
      }
    });
  }
}

function updateWebsiteList(websites) {
  const list = document.getElementById('websiteList');
  list.innerHTML = '';
  websites.forEach(site => {
    const li = document.createElement('li');
    li.textContent = site;
    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'Remove';
    removeBtn.onclick = () => removeWebsite(site);
    li.appendChild(removeBtn);
    list.appendChild(li);
  });
}

function removeWebsite(site) {
  chrome.storage.sync.get({websites: []}, (data) => {
    const updatedWebsites = data.websites.filter(w => w !== site);
    chrome.storage.sync.set({websites: updatedWebsites}, () => {
      updateWebsiteList(updatedWebsites);
    });
  });
}

function saveSettings() {
  const timerDuration = document.getElementById('timerDuration').value;
  chrome.storage.sync.set({timerDuration: parseInt(timerDuration)}, () => {
    alert('Settings saved');
  });
}

function resetSettings() {
  const defaultSettings = {
    websites: [],
    timerDuration: 30
  };
  chrome.storage.sync.set(defaultSettings, () => {
    loadSettings();
    alert('Settings reset to default');
  });
}
</file>

</repository_files>
