<summary>

<header>
Repopack Output File
This file was generated by Repopack on: 2024-10-12T00:50:40.984Z
</header>

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository structure
3. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the file path attributes to distinguish
  between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.


</notes>

<additional_info>
For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</summary>

<repository_structure>
.gitignore
background/service-worker.js
manifest.json
overlay/overlay.css
overlay/overlay.html
overlay/overlay.js
popup/popup.css
popup/popup.html
popup/popup.js
README.md
scripts/chess-game.js
scripts/puzzle-generator.js
settings/settings.css
settings/settings.html
settings/settings.js
</repository_structure>

<repository_files>

<file path=".gitignore">
#Ignore repopack
repopack-output.txt
# Ignore Puzzles folder
Puzzles/

# Ignore common files
.DS_Store
Thumbs.db

# Ignore node modules if you decide to use npm in the future
node_modules/

# Ignore any log files
*.log

# Ignore .vscode settings
.vscode/

# Ignore any sensitive or environment-specific files
config.json
secrets.json
</file>

<file path="background/service-worker.js">
let websiteTimers = {};
let settings = {
  websites: [],
  timerDuration: 30 // Default 30 minutes
};

chrome.runtime.onInstalled.addListener(() => {
  chrome.storage.sync.get(['websites', 'timerDuration'], (data) => {
    if (data.websites) settings.websites = data.websites;
    if (data.timerDuration) settings.timerDuration = data.timerDuration;
  });
});

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (changeInfo.status === 'complete' && tab.url) {
    const website = settings.websites.find(site => tab.url.includes(site));
    if (website) {
      startTimer(tabId, website);
    }
  }
});

function startTimer(tabId, website) {
  if (websiteTimers[tabId]) {
    clearTimeout(websiteTimers[tabId]);
  }
  websiteTimers[tabId] = setTimeout(() => {
    chrome.tabs.sendMessage(tabId, { action: "showOverlay" });
  }, settings.timerDuration * 60 * 1000);
}

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  switch (request.action) {
    case "getTimerStatus":
      if (sender.tab) {
        const remainingTime = getTimerStatus(sender.tab.id);
        sendResponse({ status: `Time remaining: ${remainingTime} minutes` });
      } else {
        sendResponse({ status: "No active timer" });
      }
      break;
    case "overlayCompleted":
      if (request.solved) {
        resetTimer(sender.tab.id);
      }
      break;
    case "updateSettings":
      updateSettings(request.settings);
      break;
  }
  return true; // Required for sendResponse to work
});

function getTimerStatus(tabId) {
  if (!websiteTimers[tabId]) return 0;
  const elapsed = Date.now() - websiteTimers[tabId].startTime;
  return Math.max(0, Math.round((settings.timerDuration * 60 * 1000 - elapsed) / (60 * 1000)));
}

function resetTimer(tabId) {
  if (websiteTimers[tabId]) {
    clearTimeout(websiteTimers[tabId]);
    delete websiteTimers[tabId];
  }
}

function updateSettings(newSettings) {
  settings = { ...settings, ...newSettings };
  chrome.storage.sync.set(settings);
  // Optionally reset all timers here if settings have changed significantly
}

// Listen for tab removal to clean up timers
chrome.tabs.onRemoved.addListener((tabId) => {
  if (websiteTimers[tabId]) {
    clearTimeout(websiteTimers[tabId]);
    delete websiteTimers[tabId];
  }
});
</file>

<file path="manifest.json">
{
    "manifest_version": 3,
    "name": "Chessboard Popup",
    "version": "2.0",
    "description": "Chess puzzles and timed website breaks with interactive chessboard",
    "icons": {
      "16": "images/icon-16.png",
      "32": "images/icon-32.png",
      "48": "images/icon-48.png",
      "128": "images/icon-128.png"
    },
    "action": {
      "default_popup": "popup/popup.html",
      "default_icon": {
        "16": "images/icon-16.png",
        "32": "images/icon-32.png",
        "48": "images/icon-48.png",
        "128": "images/icon-128.png"
      }
    },
    "permissions": [
      "storage",
      "alarms",
      "activeTab",
      "tabs"
    ],
    "host_permissions": [
      "*://blank.org/*"
    ],
    "background": {
      "service_worker": "background/service-worker.js"
    },
    "options_page": "settings/settings.html",
    "content_scripts": [
      {
        "matches": ["*://blank.org/*"],
        "js": [
          "libs/jquery.min.js",
          "libs/chessboardjs-1.0.0/js/chessboard-1.0.0.min.js",
          "libs/chess.js",
          "scripts/chess-game.js",
          "scripts/puzzle-generator.js",
          "scripts/timer.js",
          "overlay/overlay.js"
        ],
        "css": [
          "libs/chessboardjs-1.0.0/css/chessboard-1.0.0.min.css",
          "styles/chessboard.css"
        ]
      }
    ],
    "web_accessible_resources": [
      {
        "resources": [
          "libs/chessboardjs-1.0.0/img/chesspieces/wikipedia/*",
          "Puzzles/puzzles.json",
          "overlay/overlay.html",
          "images/solved.webm",
          "overlay/overlay.css"
        ],
        "run_at": "document_end",
        "matches": ["*://blank.org/*"]
      }
    ]
  }
</file>

<file path="overlay/overlay.css">
#chessOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}
#puzzleContainer {
  background: white;
  padding: 30px;
  border-radius: 15px;
  box-shadow: 0 0 20px rgba(0,0,0,0.3);
  display: flex;
  flex-direction: column;
  align-items: center;
}
#timerDisplay {
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 20px;
  color: #333;
}
#chessboard {
  width: 600px;
  height: 600px;
  margin-bottom: 20px;
}
#puzzleInfo {
  text-align: center;
  margin-top: 20px;
  font-family: Arial, sans-serif;
}
#puzzlePrompt {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 10px;
}
#puzzleElo {
  font-size: 16px;
  color: #666;
  margin-bottom: 10px;
}
.button {
  padding: 10px 20px;
  font-size: 16px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.3s;
}
.button:hover {
  background-color: #45a049;
}
.button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}
#closeOverlay {
  margin-top: 20px;
  margin-bottom: 10px;
}
#controlBar {
  display: flex;
  justify-content: space-between;
  width: 100%;
  margin-top: 20px;
}
#controlBar .button {
  flex: 1;
  margin: 0 5px;
}
.piece-417db {
  z-index: 10000 !important;
}
.highlight-green {
  box-shadow: inset 0 0 3px 3px green;
}
.highlight-move {
  background-color: rgba(255, 255, 0, 0.5) !important;
}
.highlight-square::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 25%;
  height: 25%;
  background-color: rgba(10, 128, 10, 0.5);
  border-radius: 50%;
  z-index: 10;
}
#solvedAnimation {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10001;
  display: none;
  width: 100px;
  height: auto;
}
</file>

<file path="overlay/overlay.html">
<div id="chessOverlay">
  <div id="puzzleContainer">
    <div id="timerDisplay"></div>
    <div id="chessboard"></div>
    <div id="puzzleInfo">
      <p id="puzzlePrompt">Solve the puzzle to continue browsing</p>
      <p id="puzzleElo"></p>
    </div>
    <button id="closeOverlay" class="button" disabled>Close</button>
    <div id="controlBar">
      <button id="showHint" class="button">Show Hint</button>
      <button id="undoMove" class="button">Undo</button>
      <button id="redoMove" class="button">Redo</button>
      <button id="skipPuzzle" class="button">Skip Puzzle</button>
    </div>
  </div>
  <video id="solvedAnimation" muted></video>
</div>
</file>

<file path="overlay/overlay.js">
class ChessPuzzleOverlay {
  constructor() {
    this.chessGame = null;
    this.puzzleGenerator = null;
    this.timer = null;
    this.puzzleSolved = false;
    this.solvedAnimationUrl = chrome.runtime.getURL('images/solved.webm');
  }

  async injectOverlay() {
    console.log("Injecting overlay");
    
    try {
      // Load HTML
      const htmlUrl = chrome.runtime.getURL('overlay/overlay.html');
      const htmlResponse = await fetch(htmlUrl);
      const htmlText = await htmlResponse.text();

      // Load CSS
      const cssUrl = chrome.runtime.getURL('overlay/overlay.css');
      const cssResponse = await fetch(cssUrl);
      const cssText = await cssResponse.text();

      // Combine HTML and CSS
      const combinedHTML = `
        <style>${cssText}</style>
        ${htmlText}
      `;

      // Inject the combined HTML and CSS into the page
      document.body.insertAdjacentHTML('beforeend', combinedHTML);

      // Set the solved animation URL
      document.getElementById('solvedAnimation').src = this.solvedAnimationUrl;

      // Initialize event listeners and other necessary setup
      this.initializeOverlayElements();
    } catch (error) {
      console.error('Error injecting overlay:', error);
    }
  }

  initializeOverlayElements() {
    document.getElementById('closeOverlay').addEventListener('click', this.closeOverlay.bind(this));
    document.getElementById('showHint').addEventListener('click', this.showHint.bind(this));
    document.getElementById('undoMove').addEventListener('click', this.undoMove.bind(this));
    document.getElementById('redoMove').addEventListener('click', this.redoMove.bind(this));
    document.getElementById('skipPuzzle').addEventListener('click', this.skipPuzzle.bind(this));
  }

  initializeOverlay() {
    this.chessGame = new ChessGame('chessboard', {
      boardId: 'chessboard',
      onMove: this.onMove.bind(this),
      onPuzzleSolved: this.onPuzzleSolved.bind(this)
    });
    this.chessGame.init();
    this.puzzleGenerator = new PuzzleGenerator();
  }

  onMove(move) {
    // This method can be used for any additional logic needed after a move
    // The correctness of the move is now handled in the ChessGame class
  }

  onPuzzleSolved() {
    this.endPuzzle(true);
    this.playSolvedAnimation();
  }

  playSolvedAnimation() {
    const video = document.getElementById('solvedAnimation');
    video.style.display = 'block';
    video.currentTime = 0;  // Reset to the beginning
    video.play().then(() => {
      video.onended = () => {
        video.style.display = 'none';
      };
    }).catch(error => {
      console.error('Error playing video:', error);
      video.style.display = 'none';
    });
  }

  async showOverlay() {
    await this.injectOverlay();
    this.initializeOverlay();
    document.getElementById('chessOverlay').style.display = 'flex';
    this.loadNewPuzzle();
    this.startTimer();
  }

  async loadNewPuzzle() {
    try {
      const puzzle = await this.puzzleGenerator.getRandomPuzzle();
      this.chessGame.setPuzzle(puzzle.fen, puzzle.moves);
      this.puzzleSolved = false;
      this.updatePuzzleInfo(puzzle);
    } catch (error) {
      console.error('Error loading puzzle:', error);
      // Handle the error appropriately (e.g., show a message to the user)
    }
  }

  updatePuzzleInfo(puzzle) {
    document.getElementById('puzzlePrompt').textContent = `Solve this puzzle to continue browsing`;
    document.getElementById('puzzleElo').textContent = `Puzzle Elo: ${puzzle.elo}`;
  }

  startTimer() {
    let timeLeft = 300; // 5 minutes
    this.timer = setInterval(() => {
      timeLeft--;
      document.getElementById('timerDisplay').textContent = `Time left: ${timeLeft}s`;
      if (timeLeft <= 0) {
        this.endPuzzle(false);
      }
    }, 1000);
  }

  endPuzzle(solved) {
    clearInterval(this.timer);
    this.puzzleSolved = solved;
    document.getElementById('closeOverlay').disabled = false;
    document.getElementById('puzzlePrompt').textContent = solved ? 'Puzzle solved! You can close the overlay.' : 'Time\'s up! You can close the overlay.';
    if (solved) {
      this.playSolvedAnimation();
    }
  }

  closeOverlay() {
    if (this.puzzleSolved || document.getElementById('closeOverlay').disabled === false) {
      document.getElementById('chessOverlay').style.display = 'none';
      chrome.runtime.sendMessage({action: "overlayCompleted", solved: this.puzzleSolved});
    }
  }

  showHint() {
    const hint = this.puzzleGenerator.getHint();
    alert(hint); // You might want to display this in a more user-friendly way
  }

  undoMove() {
    this.chessGame.undoMove();
  }

  redoMove() {
    this.chessGame.redoMove();
  }

  skipPuzzle() {
    this.endPuzzle(false);
    this.loadNewPuzzle();
  }
}

let chessPuzzleOverlay = null;

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log("Received message:", request);
  if (request.action === "showOverlay") {
    if (!chessPuzzleOverlay) {
      chessPuzzleOverlay = new ChessPuzzleOverlay();
    }
    chessPuzzleOverlay.showOverlay();
  }
});

console.log("Overlay script ready");
</file>

<file path="popup/popup.css">
body {
    width: 200px;
    padding: 10px;
  }
  
  button {
    width: 100%;
    margin: 5px 0;
    padding: 5px;
  }
  
  #timerStatus {
    margin-top: 10px;
    text-align: center;
  }
</file>

<file path="popup/popup.html">
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="popup.css">
</head>
<body>
  <h1>Chessboard Popup</h1>
  <button id="settingsBtn">Settings</button>
  <button id="triggerOverlayBtn">Show Chess Puzzle</button>
  <div id="timerStatus"></div>
  <script src="popup.js"></script>
</body>
</html>
</file>

<file path="popup/popup.js">
document.getElementById('settingsBtn').addEventListener('click', () => {
    chrome.runtime.openOptionsPage();
  });
  
  document.getElementById('triggerOverlayBtn').addEventListener('click', () => {
    chrome.tabs.query({active: true, currentWindow: true}, (tabs) => {
      chrome.tabs.sendMessage(tabs[0].id, {action: "showOverlay"});
    });
  });
  
  // Fetch and display timer status
  chrome.runtime.sendMessage({action: "getTimerStatus"}, (response) => {
    document.getElementById('timerStatus').textContent = response.status;
  });
</file>

<file path="README.md">
# Chess Puzzle Extension

This Chrome extension provides an interactive chess puzzle solving experience. It helps users improve their chess skills by presenting them with timed puzzles during their browsing sessions.

## Features

- Timed chess puzzles that appear as overlays on specified websites
- Customizable timer duration and website list
- Interactive chessboard with drag-and-drop functionality
- Puzzle difficulty levels (Easy, Medium, Hard)
- Hint system for challenging puzzles
- Settings page for customization

## Project Structure

- `manifest.json`: The extension manifest file
- `background/`: Contains the service worker for the extension
  - `service-worker.js`: Manages the background processes, including timers and messaging
- `images/`: Icon images for the extension
- `overlay/`: Contains the overlay functionality
  - `overlay.js`: Manages the chess puzzle overlay display and interaction
- `popup/`: Contains the extension popup
  - `popup.html`: HTML structure for the popup
  - `popup.css`: Styles for the popup
  - `popup.js`: JavaScript for popup functionality
- `scripts/`: Contains the main chess game and puzzle generator scripts
  - `chess-game.js`: Implements the chess game logic
  - `puzzle-generator.js`: Manages puzzle generation and difficulty
- `settings/`: Contains the settings page
  - `settings.html`: HTML structure for the settings page
  - `settings.css`: Styles for the settings page
  - `settings.js`: JavaScript for settings functionality
- `styles/`: Contains additional styles
  - `chessboard.css`: Styles for the chessboard

## Libraries

The `libs/` directory is not included in this repository. You need to obtain the following libraries:

- chess.js: A JavaScript chess library for chess move generation/validation, piece placement/movement, and check/checkmate/draw detection
- jquery.min.js: jQuery library for DOM manipulation
- chessboard.js (version 1.0.0): A JavaScript chessboard library

Place these files in the `libs/` directory.

## Puzzles

The `Puzzles/` directory is not included in this repository. To get the puzzles:

1. Download the puzzle database from Lichess: [Lichess Puzzle Database](https://database.lichess.org/#puzzles)
2. Format the puzzles according to the Lichess puzzle format. Each puzzle should have the following structure:
   ```json
   {
     "PuzzleId": "unique_id",
     "FEN": "chess_position_in_FEN_notation",
     "Moves": "move1 move2 move3 ...",
     "Rating": 1500,
     "Themes": "theme1 theme2 theme3"
   }
   ```
3. Use the `puzzleutils.py` script in the `Puzzles/` directory to process and prepare the puzzles for use in the extension. This script should convert the Lichess puzzle format into the format used by the extension.

## Setup

1. Clone this repository
2. Obtain the required libraries and place them in the `libs/` directory
3. Prepare the puzzles and place them in the `Puzzles/` directory
4. Load the extension in Chrome:
   - Go to `chrome://extensions/`
   - Enable "Developer mode"
   - Click "Load unpacked"
   - Select the directory containing this project

## Usage

1. Click on the extension icon in Chrome to open the popup
2. Use the Settings page to customize:
   - Websites where puzzles will appear
   - Timer duration for puzzles
3. Browse the web normally. When visiting a specified website, a chess puzzle will appear after the set duration
4. Solve the puzzle to continue browsing, or wait for the timer to expire

## Development

To modify or extend the extension:

1. Edit the relevant files in the project structure
2. For major changes, update the `manifest.json` file accordingly
3. Reload the extension in Chrome to see your changes

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is open source and available under the [MIT License](LICENSE).
</file>

<file path="scripts/chess-game.js">
class ChessGame {
  constructor(boardId, config = {}) {
    this.game = new Chess();
    this.boardConfig = {
      draggable: true,
      dropOffBoard: 'snapback',
      position: 'start',
      onDragStart: this.onDragStart.bind(this),
      onDrop: this.onDrop.bind(this),
      onSnapEnd: this.onSnapEnd.bind(this),
      onMouseoutSquare: this.onMouseoutSquare.bind(this),
      onMouseoverSquare: this.onMouseoverSquare.bind(this),
      pieceTheme: function(piece) {
        return chrome.runtime.getURL('libs/chessboardjs-1.0.0/img/chesspieces/wikipedia/' + piece + '.png');
      },
      ...config
    };
    this.board = null;
    this.onMoveCallback = config.onMove || (() => {});
    this.onPuzzleSolvedCallback = config.onPuzzleSolved || (() => {});
    this.puzzleMoves = [];
    this.currentMoveIndex = 0;
  }

  init() {
    this.board = Chessboard(this.boardConfig.boardId, this.boardConfig);
  }

  setPuzzle(fen, moves) {
    this.game.load(fen);
    this.board.position(fen);
    this.puzzleMoves = moves;
    this.currentMoveIndex = 0;
    this.makeNextMove(); // Make the initial opponent move
  }

  onDragStart(source, piece) {
    if (this.game.game_over() || this.isPuzzleSolved()) return false;
    if ((this.game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (this.game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
  }

  onDrop(source, target) {
    const move = this.game.move({
      from: source,
      to: target,
      promotion: 'q'
    });
    
    if (move === null) return 'snapback';

    if (this.isCorrectMove(move)) {
      this.removeHighlights();
      this.highlightMove(move);
      this.currentMoveIndex++;
      this.onMoveCallback(move);
      
      if (!this.isPuzzleSolved()) {
        setTimeout(() => this.makeNextMove(), 300);
      } else {
        this.onPuzzleSolvedCallback();
      }
      
      return move;
    } else {
      this.game.undo();
      return 'snapback';
    }
  }

  onSnapEnd() {
    this.board.position(this.game.fen());
  }

  onMouseoverSquare(square) {
    if (this.isPuzzleSolved()) return;
    const moves = this.game.moves({ square: square, verbose: true });
    if (moves.length === 0) return;

    moves.forEach(move => this.highlightSquare(move.to));
  }

  onMouseoutSquare() {
    this.removeHighlights();
  }

  isCorrectMove(move) {
    const expectedMove = this.puzzleMoves[this.currentMoveIndex];
    return move.from + move.to === expectedMove;
  }

  makeNextMove() {
    if (this.isPuzzleSolved()) return;

    const move = this.puzzleMoves[this.currentMoveIndex];
    const result = this.game.move({
      from: move.slice(0, 2),
      to: move.slice(2, 4),
      promotion: 'q'
    });

    this.board.position(this.game.fen(), true); // Animate the move
    this.highlightMove(result);
    this.currentMoveIndex++;

    if (this.isPuzzleSolved()) {
      this.onPuzzleSolvedCallback();
    }
  }

  isPuzzleSolved() {
    return this.currentMoveIndex >= this.puzzleMoves.length;
  }

  highlightSquare(square) {
    $(`#${this.boardConfig.boardId} .square-${square}`).addClass('highlight-square');
  }

  removeHighlights() {
    $(`#${this.boardConfig.boardId} .square-55d63`).removeClass('highlight-square');
  }

  removeMoveHighlights() {
    $(`#${this.boardConfig.boardId} .square-55d63`).removeClass('highlight-move');
  }

  highlightMove(move) {
    this.removeMoveHighlights();
    $(`#${this.boardConfig.boardId} .square-${move.from}`).addClass('highlight-move');
    $(`#${this.boardConfig.boardId} .square-${move.to}`).addClass('highlight-move');
  }

  setPosition(fen) {
    this.game.load(fen);
    this.board.position(fen);
  }

  reset() {
    this.game.reset();
    this.board.start();
    this.puzzleMoves = [];
    this.currentMoveIndex = 0;
  }
}

window.ChessGame = ChessGame;
</file>

<file path="scripts/puzzle-generator.js">
class PuzzleGenerator {
  constructor() {
    this.puzzles = [];
    this.currentPuzzle = null;
    this.usedPuzzles = new Set();
    this.loaded = false;

    this.loadPuzzles();
  }

  loadPuzzles() {
    return fetch(chrome.runtime.getURL('Puzzles/puzzles.json'))
      .then(response => response.json())
      .then(data => {
        this.puzzles = data;
        this.loaded = true;
        console.log('Puzzles loaded:', this.puzzles.length);
      })
      .catch(err => {
        console.error('Failed to load puzzles:', err);
        this.loaded = false;
      });
  }

  async getRandomPuzzle() {
    if (!this.loaded) {
      await this.loadPuzzles();
    }

    console.log('Puzzles available:', this.puzzles.length);
    if (this.puzzles.length === 0) {
      this.resetPuzzles();
    }

    if (this.puzzles.length === 0) {
      throw new Error('No puzzles available');
    }

    const index = Math.floor(Math.random() * this.puzzles.length);
    this.currentPuzzle = this.puzzles.splice(index, 1)[0];
    this.usedPuzzles.add(this.currentPuzzle);
    console.log('Current puzzle:', this.currentPuzzle);
    console.log('Moves:', this.currentPuzzle.Moves);
    return {
      fen: this.currentPuzzle.FEN,
      moves: this.currentPuzzle.Moves.split(' '),
      tags: this.currentPuzzle.Themes.split(' '),
      elo: this.currentPuzzle.Rating
    };
  }

  resetPuzzles() {
    this.puzzles = [...this.usedPuzzles];
    this.usedPuzzles.clear();
  }

  checkSolution(moves) {
    if (!this.currentPuzzle) return false;

    const solutionMoves = this.currentPuzzle.Moves.split(' ');
    return moves.join(' ') === solutionMoves.join(' ');
  }

  getHint() {
    if (!this.currentPuzzle) return null;

    const firstMove = this.currentPuzzle.Moves.split(' ')[0];
    return `Try moving from ${firstMove.slice(0, 2)} to ${firstMove.slice(2, 4)}`;
  }
}

window.PuzzleGenerator = PuzzleGenerator;
</file>

<file path="settings/settings.css">
body {
  font-family: Arial, sans-serif;
  line-height: 1.6;
  color: #333;
  background-color: #f4f4f4;
  margin: 0;
  padding: 20px;
}

.container {
  max-width: 800px;
  margin: 0 auto;
  background-color: #fff;
  padding: 20px;
  border-radius: 5px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

h1 {
  color: #fff;
  background-color: #8bc34a;
  padding: 20px;
  margin: -20px -20px 20px -20px;
  border-radius: 5px 5px 0 0;
}

.icon {
  margin-right: 10px;
}

.info-bar {
  background-color: #f1f1f1;
  padding: 10px;
  margin-bottom: 20px;
  border-radius: 5px;
}

.setting {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 20px;
  border-bottom: 1px solid #eee;
}

.setting-text h2 {
  margin: 0;
  font-size: 18px;
}

.setting-text p {
  margin: 5px 0 0 0;
  color: #666;
}

.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
}

input:checked + .slider {
  background-color: #8bc34a;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}

.add-website {
  display: flex;
}

#websiteInput {
  flex-grow: 1;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px 0 0 5px;
}

#addWebsite {
  padding: 10px 20px;
  background-color: #8bc34a;
  color: white;
  border: none;
  border-radius: 0 5px 5px 0;
  cursor: pointer;
}

.website-list {
  list-style-type: none;
  padding: 0;
}

.website-list li {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 0;
  border-bottom: 1px solid #eee;
}

.website-list li:last-child {
  border-bottom: none;
}

.website-controls {
  display: flex;
  align-items: center;
}

.website-controls select {
  margin: 0 10px;
  padding: 5px;
}

.remove-website {
  background: none;
  border: none;
  color: #e74c3c;
  cursor: pointer;
}

.footer {
  margin-top: 20px;
  text-align: center;
  color: #666;
}

.powered-by {
  display: block;
  margin-top: 10px;
}

a {
  color: #8bc34a;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}
</file>

<file path="settings/settings.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Limit Settings - Chess Puzzle Extension</title>
  <link rel="stylesheet" href="settings.css">
</head>
<body>
  <div class="container">
    <h1><span class="icon">⏱</span> Limit settings</h1>
    
    <div class="info-bar">
      math and coding challnges coming soon?<a href="#">Support devs</a>.
    </div>
    
    <div class="setting">
      <div class="setting-text">
        <h2>Show timer</h2>
        <p>Display a timer for time left on websites</p>
      </div>
      <label class="switch">
        <input type="checkbox" id="showTimer" checked>
        <span class="slider round"></span>
      </label>
    </div>
    
    <div class="setting">
      <div class="setting-text">
        <h2>Add website</h2>
        <p>Add a new website to the list below</p>
      </div>
      <div class="add-website">
        <input type="text" id="websiteInput" placeholder="Enter website URL">
        <button id="addWebsite">Add Website</button>
      </div>
    </div>
    
    <div class="setting">
      <div class="setting-text">
        <h2>Daily website limits</h2>
        <p>Enter your time limit for these sites. and maximum sessions.</p>
      </div>
      <ul id="websiteList" class="website-list"></ul>
    </div>
    
    <div class="footer">
      Enjoying Limit? <a href="#">Please leave us a rating and review</a>
      <span class="powered-by">powered by <a href="#">ADHD</a></span>
    </div>
  </div>
  <script src="settings.js"></script>
</body>
</html>S
</file>

<file path="settings/settings.js">
document.addEventListener('DOMContentLoaded', loadSettings);
document.getElementById('addWebsite').addEventListener('click', addWebsite);

function loadSettings() {
  chrome.storage.sync.get(['websites', 'showTimer'], (data) => {
    if (data.websites) updateWebsiteList(data.websites);
    if (data.showTimer !== undefined) document.getElementById('showTimer').checked = data.showTimer;
  });
}

function addWebsite() {
  const input = document.getElementById('websiteInput');
  const website = input.value.trim();
  if (website) {
    chrome.storage.sync.get({websites: []}, (data) => {
      if (!data.websites.includes(website)) {
        data.websites.push(website);
        chrome.storage.sync.set({websites: data.websites}, () => {
          updateWebsiteList(data.websites);
          input.value = '';
        });
      } else {
        alert('This website is already in the list.');
      }
    });
  }
}

function updateWebsiteList(websites) {
  const list = document.getElementById('websiteList');
  list.innerHTML = '';
  websites.forEach(site => {
    const li = document.createElement('li');
    li.innerHTML = `
      <span>${site}</span>
      <div class="website-controls">
        <select class="time-select">
          ${generateTimeOptions()}
        </select>
        <span>min.</span>
        <select class="session-select">
          ${generateSessionOptions()}
        </select>
        <button class="remove-website" data-site="${site}">✖</button>
      </div>
    `;
    list.appendChild(li);
  });
  
  // Add event listeners to remove buttons
  document.querySelectorAll('.remove-website').forEach(btn => {
    btn.addEventListener('click', function() {
      removeWebsite(this.getAttribute('data-site'));
    });
  });
}

function removeWebsite(site) {
  chrome.storage.sync.get({websites: []}, (data) => {
    const updatedWebsites = data.websites.filter(w => w !== site);
    chrome.storage.sync.set({websites: updatedWebsites}, () => {
      updateWebsiteList(updatedWebsites);
    });
  });
}

function generateTimeOptions() {
  let options = '';
  for (let i = 5; i <= 60; i += 5) {
    options += `<option value="${i}">${i}</option>`;
  }
  return options;
}

function generateSessionOptions() {
  let options = '';
  for (let i = 1; i <= 10; i++) {
    options += `<option value="${i}">${i}</option>`;
  }
  return options;
}

// Save showTimer setting when toggled
document.getElementById('showTimer').addEventListener('change', function() {
  chrome.storage.sync.set({showTimer: this.checked});
});
</file>

</repository_files>
