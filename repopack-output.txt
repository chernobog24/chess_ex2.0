<summary>

<header>
Repopack Output File
This file was generated by Repopack on: 2024-10-14T22:47:15.482Z
</header>

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository structure
3. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the file path attributes to distinguish
  between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.


</notes>

<additional_info>
For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</summary>

<repository_structure>
.gitignore
background/service-worker.js
manifest.json
overlay/overlay.css
overlay/overlay.html
overlay/overlay.js
overlay/timerBar.js
popup/popup.css
popup/popup.html
popup/popup.js
README.md
scripts/chess-game.js
scripts/puzzle-generator.js
settings/settings.css
settings/settings.html
settings/settings.js
</repository_structure>

<repository_files>

<file path=".gitignore">
#Ignore repopack
repopack-output.txt
# Ignore Puzzles folder
Puzzles/

# Ignore common files
.DS_Store
Thumbs.db

# Ignore node modules if you decide to use npm in the future
node_modules/

# Ignore any log files
*.log

# Ignore .vscode settings
.vscode/

# Ignore any sensitive or environment-specific files
config.json
secrets.json
</file>

<file path="background/service-worker.js">
// State management
const state = {
  websiteTimers: {},
  settings: {
    websites: [],
    globalSettings: {
      minElo: 800,
      maxElo: 2000,
      timeBonus: 2,
      wrongMovePenalty: 1,
      hintPenalty: 1,
      skipPenalty: 2
    }
  }
};

// Initialization
chrome.runtime.onInstalled.addListener(initializeExtension);

// Event listeners
chrome.tabs.onUpdated.addListener(handleTabUpdate);
chrome.tabs.onRemoved.addListener(handleTabRemoval);
chrome.storage.onChanged.addListener(handleStorageChange);
chrome.runtime.onMessage.addListener(handleMessage);

// Initialization function
function initializeExtension() {
  console.log('Extension installed. Loading settings...');
  loadSettings();
}

// Settings management
function loadSettings() {
  chrome.storage.sync.get(['websites', 'globalSettings'], (data) => {
    if (data.websites) state.settings.websites = data.websites;
    if (data.globalSettings) state.settings.globalSettings = data.globalSettings;
    console.log('Settings loaded:', state.settings);
  });
}

// Tab management
function handleTabUpdate(tabId, changeInfo, tab) {
  if (changeInfo.status === 'complete' && tab.url) {
    console.log(`Tab updated: ${tabId}, URL: ${tab.url}`);
    const website = findMatchingWebsite(tab.url);
    if (website) {
      console.log(`Monitored website detected: ${website.url}`);
      checkPuzzleRequirement(tabId, website);
      updateTimerBar(tabId, website);  // Changed from initializeTimerBar
    }
  }
}
function findMatchingWebsite(url) {
  return state.settings.websites.find(site => url.includes(site.url));
}

// Puzzle management
function checkPuzzleRequirement(tabId, website) {
  console.log(`Checking puzzle requirement for website: ${website.url}`);
  const timer = state.websiteTimers[website.url];
  if (!timer || timer.status === 'expired') {
    console.log(`Puzzle required for website ${website.url}. Reason: ${!timer ? 'New session' : 'Session expired'}`);
    chrome.tabs.sendMessage(tabId, { target: 'overlay', action: "showOverlay", reason: "start" });
  } else if (timer.status === 'active') {
    console.log(`Active session for website ${website.url}. No puzzle required.`);
  }
}

// Timer management
function updateTimerBar(tabId, website) {
  const remainingTime = getTimerStatus(website.url);
  chrome.tabs.sendMessage(tabId, {
    target: 'timerBar',
    action: "updateTimerBar",
    timeLeft: remainingTime * 60, // Convert minutes to seconds
    totalTime: website.timePerSession * 60
  });
}
function startTimer(website) {
  console.log(`Starting timer for website: ${website.url}`);
  if (state.websiteTimers[website.url]) {
    console.log(`Clearing existing timer for website ${website.url}`);
    clearTimeout(state.websiteTimers[website.url].timer);
  }
  
  state.websiteTimers[website.url] = {
    status: 'active',
    startTime: Date.now(),
    timer: setTimeout(() => {
      console.log(`Timer expired for website ${website.url}`);
      state.websiteTimers[website.url].status = 'expired';
      notifyAllTabs(website.url);
    }, website.timePerSession * 60 * 1000)
  };
  console.log(`Timer set for ${website.timePerSession} minutes`);
}

function getTimerStatus(websiteUrl) {
  const timer = state.websiteTimers[websiteUrl];
  if (!timer || timer.status !== 'active') {
    console.log(`No active timer for website ${websiteUrl}`);
    return 0;
  }
  const website = findMatchingWebsite(websiteUrl);
  if (!website) return 0;

  const elapsedTime = Date.now() - timer.startTime;
  const remainingTime = Math.max(0, Math.round((website.timePerSession * 60 * 1000 - elapsedTime) / (60 * 1000)));
  console.log(`Timer status for website ${websiteUrl}: ${remainingTime} minutes remaining`);
  return remainingTime;
}

// Notification management
function notifyAllTabs(websiteUrl) {
  chrome.tabs.query({url: `*://${websiteUrl}/*`}, (tabs) => {
    tabs.forEach(tab => {
      chrome.tabs.sendMessage(tab.id, { target: 'overlay', action: "showOverlay", reason: "timeUp" });
    });
  });
}

// Message handling
function handleMessage(request, sender, sendResponse) {
  console.log('Message received:', request);
  switch (request.action) {
    case "overlayCompleted":
      handleOverlayCompleted(sender, request, sendResponse);
      break;
    case "getTimerStatus":
      handleGetTimerStatus(sender, sendResponse);
      break;
  }
  return true; // Required for sendResponse to work
}

function handleOverlayCompleted(sender, request, sendResponse) {
  if (sender.tab && request.solved) {
    const websiteUrl = new URL(sender.tab.url).hostname;
    const website = findMatchingWebsite(websiteUrl);
    if (website) {
      console.log(`Puzzle solved for website: ${website.url}`);
      startTimer(website);
      updateTimerBar(sender.tab.id, website);  // Changed from initializeTimerBar
      sendResponse({ status: "Timer started" });
    }
  }
}
function handleGetTimerStatus(sender, sendResponse) {
  if (sender.tab) {
    const websiteUrl = new URL(sender.tab.url).hostname;
    const website = findMatchingWebsite(websiteUrl);
    if (website) {
      const remainingTime = getTimerStatus(website.url);
      console.log(`Timer status requested for website ${website.url}. Remaining time: ${remainingTime} minutes`);
      sendResponse({ status: `Time remaining: ${remainingTime} minutes` });
    } else {
      sendResponse({ status: "No active timer for this website" });
    }
  } else {
    console.log('Timer status requested, but no tab information available');
    sendResponse({ status: "No active timer" });
  }
}

// Tab removal handling
function handleTabRemoval(tabId, removeInfo) {
  console.log(`Tab ${tabId} removed`);
  chrome.tabs.query({}, (tabs) => {
    Object.keys(state.websiteTimers).forEach(websiteUrl => {
      if (!tabs.some(tab => tab.url.includes(websiteUrl))) {
        console.log(`Cleaning up timer for website ${websiteUrl}`);
        clearTimeout(state.websiteTimers[websiteUrl].timer);
        delete state.websiteTimers[websiteUrl];
      }
    });
  });
}

// Storage change handling
function handleStorageChange(changes, namespace) {
  for (let key in changes) {
    let storageChange = changes[key];
    console.log('Storage key "%s" in namespace "%s" changed. ' +
                'Old value was "%s", new value is "%s".',
                key,
                namespace,
                storageChange.oldValue,
                storageChange.newValue);
    
    if (key === 'websites' || key === 'globalSettings') {
      state.settings[key] = storageChange.newValue;
    }
  }
  console.log('Updated settings:', state.settings);
}

console.log('Service worker initialized');
</file>

<file path="manifest.json">
{
    "manifest_version": 3,
    "name": "Chessboard Popup",
    "version": "2.0",
    "description": "Chess puzzles and timed website breaks with interactive chessboard",
    "icons": {
      "16": "images/icon-16.png",
      "32": "images/icon-32.png",
      "48": "images/icon-48.png",
      "128": "images/icon-128.png"
    },
    "action": {
      "default_popup": "popup/popup.html",
      "default_icon": {
        "16": "images/icon-16.png",
        "32": "images/icon-32.png",
        "48": "images/icon-48.png",
        "128": "images/icon-128.png"
      }
    },
    "permissions": [
      "storage",
      "alarms",
      "activeTab",
      "tabs"
    ],
    "host_permissions": [
      "<all_urls>"
    ],
    "background": {
      "service_worker": "background/service-worker.js"
    },
    "options_page": "settings/settings.html",
    "content_scripts": [
      {
        "matches": ["<all_urls>"],
        "js": [
          "libs/jquery.min.js",
          "libs/chessboardjs-1.0.0/js/chessboard-1.0.0.min.js",
          "libs/chess.js",
          "scripts/chess-game.js",
          "scripts/puzzle-generator.js",
          "scripts/timer.js",
          "overlay/timerBar.js",
          "overlay/overlay.js"
        ],
        "css": [
          "libs/chessboardjs-1.0.0/css/chessboard-1.0.0.min.css",
          "styles/chessboard.css"
        ]
      }
    ],
    "web_accessible_resources": [
      {
        "resources": [
          "libs/chessboardjs-1.0.0/img/chesspieces/wikipedia/*",
          "Puzzles/puzzles.json",
          "overlay/overlay.html",
          "images/solved.webm",
          "overlay/overlay.css"
        ],
        "run_at": "document_end",
        "matches": ["<all_urls>"]
      }
    ]
  }
</file>

<file path="overlay/overlay.css">
#chessOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}
#puzzleContainer {
  background: white;
  padding: 30px;
  border-radius: 15px;
  box-shadow: 0 0 20px rgba(0,0,0,0.3);
  display: flex;
  flex-direction: column;
  align-items: center;
}
#timerDisplay {
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 20px;
  color: #333;
}
#chessboard {
  width: 600px;
  height: 600px;
  margin-bottom: 20px;
}
#puzzleInfo {
  text-align: center;
  margin-top: 20px;
  font-family: Arial, sans-serif;
}
#puzzlePrompt {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 10px;
}
#puzzleElo {
  font-size: 16px;
  color: #666;
  margin-bottom: 10px;
}
.button {
  padding: 10px 20px;
  font-size: 16px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.3s;
}
.button:hover {
  background-color: #45a049;
}
.button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}
#closeOverlay {
  margin-top: 20px;
  margin-bottom: 10px;
}
#controlBar {
  display: flex;
  justify-content: space-between;
  width: 100%;
  margin-top: 20px;
}
#controlBar .button {
  flex: 1;
  margin: 0 5px;
}
.piece-417db {
  z-index: 10000 !important;
}
.highlight-green {
  box-shadow: inset 0 0 3px 3px green;
}
.highlight-move {
  background-color: rgba(255, 255, 0, 0.5) !important;
}
.highlight-square::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 25%;
  height: 25%;
  background-color: rgba(10, 128, 10, 0.5);
  border-radius: 50%;
  z-index: 10;
}
#solvedAnimation {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10001;
  display: none;
  width: 100px;
  height: auto;
}
</file>

<file path="overlay/overlay.html">
<div id="chessOverlay">
  <div id="puzzleContainer">
    <div id="timerDisplay"></div>
    <div id="chessboard"></div>
    <div id="puzzleInfo">
      <p id="puzzlePrompt">Solve the puzzle to continue browsing</p>
      <p id="puzzleElo"></p>
    </div>
    <button id="closeOverlay" class="button" disabled>Close</button>
    <div id="controlBar">
      <button id="showHint" class="button">Show Hint</button>
      <button id="undoMove" class="button">Undo</button>
      <button id="redoMove" class="button">Redo</button>
      <button id="skipPuzzle" class="button">Skip Puzzle</button>
    </div>
  </div>
  <video id="solvedAnimation" muted></video>
</div>
</file>

<file path="overlay/overlay.js">
class ChessPuzzleOverlay {
  constructor() {
    this.chessGame = null;
    this.puzzleGenerator = null;
    this.timer = null;
    this.puzzleSolved = false;
    this.solvedAnimationUrl = chrome.runtime.getURL('images/solved.webm');
  }

  async injectOverlay() {
    console.log("Injecting overlay");
    
    try {
      // Load HTML
      const htmlUrl = chrome.runtime.getURL('overlay/overlay.html');
      const htmlResponse = await fetch(htmlUrl);
      const htmlText = await htmlResponse.text();

      // Load CSS
      const cssUrl = chrome.runtime.getURL('overlay/overlay.css');
      const cssResponse = await fetch(cssUrl);
      const cssText = await cssResponse.text();

      // Combine HTML and CSS
      const combinedHTML = `
        <style>${cssText}</style>
        ${htmlText}
      `;

      // Inject the combined HTML and CSS into the page
      document.body.insertAdjacentHTML('beforeend', combinedHTML);

      // Set the solved animation URL
      document.getElementById('solvedAnimation').src = this.solvedAnimationUrl;

      // Initialize event listeners and other necessary setup
      this.initializeOverlayElements();
    } catch (error) {
      console.error('Error injecting overlay:', error);
    }
  }

  initializeOverlayElements() {
    document.getElementById('closeOverlay').addEventListener('click', this.closeOverlay.bind(this));
    document.getElementById('showHint').addEventListener('click', this.showHint.bind(this));
    document.getElementById('undoMove').addEventListener('click', this.undoMove.bind(this));
    document.getElementById('redoMove').addEventListener('click', this.redoMove.bind(this));
    document.getElementById('skipPuzzle').addEventListener('click', this.skipPuzzle.bind(this));
  }

  initializeOverlay() {
    this.chessGame = new ChessGame('chessboard', {
      boardId: 'chessboard',
      onMove: this.onMove.bind(this),
      onPuzzleSolved: this.onPuzzleSolved.bind(this)
    });
    this.chessGame.init();
    this.puzzleGenerator = new PuzzleGenerator();
  }

  onMove(move) {
    // This method can be used for any additional logic needed after a move
    // The correctness of the move is now handled in the ChessGame class
  }

  onPuzzleSolved() {
    this.endPuzzle(true);
    this.playSolvedAnimation();
  }

  playSolvedAnimation() {
    const video = document.getElementById('solvedAnimation');
    video.style.display = 'block';
    video.currentTime = 0;  // Reset to the beginning
    video.play().then(() => {
      video.onended = () => {
        video.style.display = 'none';
      };
    }).catch(error => {
      console.error('Error playing video:', error);
      video.style.display = 'none';
    });
  }

  async showOverlay() {
    await this.injectOverlay();
    this.initializeOverlay();
    document.getElementById('chessOverlay').style.display = 'flex';
    this.loadNewPuzzle();
    this.startTimer();
  }

  async loadNewPuzzle() {
    try {
      const puzzle = await this.puzzleGenerator.getRandomPuzzle();
      this.chessGame.setPuzzle(puzzle.fen, puzzle.moves);
      this.puzzleSolved = false;
      this.updatePuzzleInfo(puzzle);
    } catch (error) {
      console.error('Error loading puzzle:', error);
      // Handle the error appropriately (e.g., show a message to the user)
    }
  }

  updatePuzzleInfo(puzzle) {
    document.getElementById('puzzlePrompt').textContent = `Solve this puzzle to continue browsing`;
    document.getElementById('puzzleElo').textContent = `Puzzle Elo: ${puzzle.elo}`;
  }

  startTimer() {
    let timeLeft = 300; // 5 minutes
    this.timer = setInterval(() => {
      timeLeft--;
      document.getElementById('timerDisplay').textContent = `Time left: ${timeLeft}s`;
      if (timeLeft <= 0) {
        this.endPuzzle(false);
      }
    }, 1000);
  }

  endPuzzle(solved) {
    clearInterval(this.timer);
    this.puzzleSolved = solved;
    document.getElementById('closeOverlay').disabled = false;
    document.getElementById('puzzlePrompt').textContent = solved ? 'Puzzle solved! You can close the overlay.' : 'Time\'s up! You can close the overlay.';
    if (solved) {
      this.playSolvedAnimation();
    }
  }

  closeOverlay() {
    if (this.puzzleSolved) {
      document.getElementById('chessOverlay').remove();
      chrome.runtime.sendMessage({target: 'background', action: "overlayCompleted", solved: true});
      chessPuzzleOverlay = null;  // Reset the global reference
    }
  }

  showHint() {
    const hint = this.puzzleGenerator.getHint();
    alert(hint); // You might want to display this in a more user-friendly way
  }

  undoMove() {
    this.chessGame.undoMove();
  }

  redoMove() {
    this.chessGame.redoMove();
  }

  skipPuzzle() {
    this.loadNewPuzzle();
  }
}

let chessPuzzleOverlay = null;

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log("Received message:", request);
  if (request.target === 'overlay' && request.action === "showOverlay") {
    if (chessPuzzleOverlay) {
      chessPuzzleOverlay.closeOverlay();  // Remove existing overlay if present
    }
    chessPuzzleOverlay = new ChessPuzzleOverlay();
    chessPuzzleOverlay.showOverlay();
  }
});

console.log("Overlay script ready");
</file>

<file path="overlay/timerBar.js">
// overlay/timerBar.js

class TimerBar {
    constructor() {
        this.barElement = null;
        this.timeLeft = 0;
        this.totalTime = 0;
        this.isVisible = false;
        this.lastUpdateTime = 0;
        this.BAR_HEIGHT = '20px';  // Define bar height as a constant
      }
    
      init() {
        this.setupMessageListener();
        this.createElements();
        console.log('TimerBar initialized');
      }

      createElements() {
        if (!this.barElement) {
          this.barElement = document.createElement('div');
          this.barElement.id = 'chess-puzzle-timer-bar';
          this.barElement.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: ${this.BAR_HEIGHT};
            background-color: #4CAF50;
            z-index: 9999999;
            transition: width 0.1s linear;
          `;
          document.body.insertBefore(this.barElement, document.body.firstChild);
        }
    
        // Add CSS variable for width
        document.documentElement.style.setProperty('--timer-width', '100%');
        this.barElement.style.width = 'var(--timer-width)';
      }

    setupMessageListener() {
        chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
        if (request.target !== 'timerBar') return;
        console.log('Received message in timerBar:', request);
        switch (request.action) {
            case 'updateTimerBar':
            this.updateTimerBar(request.timeLeft, request.totalTime);
            break;
            case 'showTimer':
            this.showTimer();
            break;
            case 'hideTimer':
            this.hideTimer();
            break;
        }
        });
    }

    updateTimerBar(timeLeft, totalTime) {
        this.timeLeft = timeLeft;
        this.totalTime = totalTime;
        this.lastUpdateTime = Date.now();
        this.updateBarDisplay();
    }

    updateBarDisplay() {
        if (this.barElement) {
        const now = Date.now();
        const elapsedSinceUpdate = (now - this.lastUpdateTime) / 1000; // in seconds
        const currentTimeLeft = Math.max(0, this.timeLeft - elapsedSinceUpdate);
        const percentage = (currentTimeLeft / this.totalTime) * 100;
        this.barElement.dataset.width = `${percentage}%`;
        document.documentElement.style.setProperty('--timer-width', `${percentage}%`);

        if (currentTimeLeft > 0) {
            requestAnimationFrame(() => this.updateBarDisplay());
        }
        }
    }

    showTimer() {
        this.isVisible = true;
        if (this.barElement) {
          this.barElement.style.display = 'block';
          document.body.style.paddingTop = this.BAR_HEIGHT;
        }
      }
    
    hideTimer() {
    this.isVisible = false;
    if (this.barElement) {
        this.barElement.style.display = 'none';
        document.body.style.paddingTop = '0px';
    }
    }
}
  
// Initialize the timer bar
const timerBar = new TimerBar();
timerBar.init();
</file>

<file path="popup/popup.css">
body {
    width: 200px;
    padding: 10px;
  }
  
  button {
    width: 100%;
    margin: 5px 0;
    padding: 5px;
  }
  
  #timerStatus {
    margin-top: 10px;
    text-align: center;
  }
</file>

<file path="popup/popup.html">
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="popup.css">
</head>
<body>
  <h1>Chessboard Popup</h1>
  <button id="settingsBtn">Settings</button>
  <button id="triggerOverlayBtn">Show Chess Puzzle</button>
  <div id="timerStatus"></div>
  <script src="popup.js"></script>
</body>
</html>
</file>

<file path="popup/popup.js">
document.getElementById('settingsBtn').addEventListener('click', () => {
  chrome.runtime.openOptionsPage();
});

document.getElementById('triggerOverlayBtn').addEventListener('click', () => {
  chrome.tabs.query({active: true, currentWindow: true}, (tabs) => {
    chrome.tabs.sendMessage(tabs[0].id, {target: 'overlay', action: "showOverlay"});
  });
});

// Fetch and display timer status
chrome.runtime.sendMessage({target: 'background', action: "getTimerStatus"}, (response) => {
  document.getElementById('timerStatus').textContent = response.status;
});
</file>

<file path="README.md">
# Chess Puzzle Extension

This Chrome extension provides an interactive chess puzzle solving experience. It helps users improve their chess skills by presenting them with timed puzzles during their browsing sessions.

## Features

- Timed chess puzzles that appear as overlays on specified websites
- Customizable timer duration and website list
- Interactive chessboard with drag-and-drop functionality
- Puzzle difficulty levels (Easy, Medium, Hard)
- Hint system for challenging puzzles
- Settings page for customization

## Project Structure

- `manifest.json`: The extension manifest file
- `background/`: Contains the service worker for the extension
  - `service-worker.js`: Manages the background processes, including timers and messaging
- `images/`: Icon images for the extension
- `overlay/`: Contains the overlay functionality
  - `overlay.js`: Manages the chess puzzle overlay display and interaction
- `popup/`: Contains the extension popup
  - `popup.html`: HTML structure for the popup
  - `popup.css`: Styles for the popup
  - `popup.js`: JavaScript for popup functionality
- `scripts/`: Contains the main chess game and puzzle generator scripts
  - `chess-game.js`: Implements the chess game logic
  - `puzzle-generator.js`: Manages puzzle generation and difficulty
- `settings/`: Contains the settings page
  - `settings.html`: HTML structure for the settings page
  - `settings.css`: Styles for the settings page
  - `settings.js`: JavaScript for settings functionality
- `styles/`: Contains additional styles
  - `chessboard.css`: Styles for the chessboard

## Libraries

The `libs/` directory is not included in this repository. You need to obtain the following libraries:

- chess.js: A JavaScript chess library for chess move generation/validation, piece placement/movement, and check/checkmate/draw detection
- jquery.min.js: jQuery library for DOM manipulation
- chessboard.js (version 1.0.0): A JavaScript chessboard library

Place these files in the `libs/` directory.

## Puzzles

The `Puzzles/` directory is not included in this repository. To get the puzzles:

1. Download the puzzle database from Lichess: [Lichess Puzzle Database](https://database.lichess.org/#puzzles)
2. Format the puzzles according to the Lichess puzzle format. Each puzzle should have the following structure:
   ```json
   {
     "PuzzleId": "unique_id",
     "FEN": "chess_position_in_FEN_notation",
     "Moves": "move1 move2 move3 ...",
     "Rating": 1500,
     "Themes": "theme1 theme2 theme3"
   }
   ```
3. Use the `puzzleutils.py` script in the `Puzzles/` directory to process and prepare the puzzles for use in the extension. This script should convert the Lichess puzzle format into the format used by the extension.

## Setup

1. Clone this repository
2. Obtain the required libraries and place them in the `libs/` directory
3. Prepare the puzzles and place them in the `Puzzles/` directory
4. Load the extension in Chrome:
   - Go to `chrome://extensions/`
   - Enable "Developer mode"
   - Click "Load unpacked"
   - Select the directory containing this project

## Usage

1. Click on the extension icon in Chrome to open the popup
2. Use the Settings page to customize:
   - Websites where puzzles will appear
   - Timer duration for puzzles
3. Browse the web normally. When visiting a specified website, a chess puzzle will appear after the set duration
4. Solve the puzzle to continue browsing, or wait for the timer to expire

## Development

To modify or extend the extension:

1. Edit the relevant files in the project structure
2. For major changes, update the `manifest.json` file accordingly
3. Reload the extension in Chrome to see your changes

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is open source and available under the [MIT License](LICENSE).
</file>

<file path="scripts/chess-game.js">
class ChessGame {
  constructor(boardId, config = {}) {
    this.game = new Chess();
    this.boardConfig = {
      draggable: true,
      dropOffBoard: 'snapback',
      position: 'start',
      onDragStart: this.onDragStart.bind(this),
      onDrop: this.onDrop.bind(this),
      onSnapEnd: this.onSnapEnd.bind(this),
      onMouseoutSquare: this.onMouseoutSquare.bind(this),
      onMouseoverSquare: this.onMouseoverSquare.bind(this),
      pieceTheme: function(piece) {
        return chrome.runtime.getURL('libs/chessboardjs-1.0.0/img/chesspieces/wikipedia/' + piece + '.png');
      },
      ...config
    };
    this.board = null;
    this.onMoveCallback = config.onMove || (() => {});
    this.onPuzzleSolvedCallback = config.onPuzzleSolved || (() => {});
    this.puzzleMoves = [];
    this.currentMoveIndex = 0;
  }

  init() {
    this.board = Chessboard(this.boardConfig.boardId, this.boardConfig);
  }

  setPuzzle(fen, moves) {
    this.game.load(fen);
    this.board.position(fen);
    this.puzzleMoves = moves;
    this.currentMoveIndex = 0;
    this.makeNextMove(); // Make the initial opponent move
  }

  onDragStart(source, piece) {
    if (this.game.game_over() || this.isPuzzleSolved()) return false;
    if ((this.game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (this.game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
  }

  onDrop(source, target) {
    const move = this.game.move({
      from: source,
      to: target,
      promotion: 'q'
    });
    
    if (move === null) return 'snapback';

    if (this.isCorrectMove(move)) {
      this.removeHighlights();
      this.highlightMove(move);
      this.currentMoveIndex++;
      this.onMoveCallback(move);
      
      if (!this.isPuzzleSolved()) {
        setTimeout(() => this.makeNextMove(), 300);
      } else {
        this.onPuzzleSolvedCallback();
      }
      
      return move;
    } else {
      this.game.undo();
      return 'snapback';
    }
  }

  onSnapEnd() {
    this.board.position(this.game.fen());
  }

  onMouseoverSquare(square) {
    if (this.isPuzzleSolved()) return;
    const moves = this.game.moves({ square: square, verbose: true });
    if (moves.length === 0) return;

    moves.forEach(move => this.highlightSquare(move.to));
  }

  onMouseoutSquare() {
    this.removeHighlights();
  }

  isCorrectMove(move) {
    const expectedMove = this.puzzleMoves[this.currentMoveIndex];
    return move.from + move.to === expectedMove;
  }

  makeNextMove() {
    if (this.isPuzzleSolved()) return;

    const move = this.puzzleMoves[this.currentMoveIndex];
    const result = this.game.move({
      from: move.slice(0, 2),
      to: move.slice(2, 4),
      promotion: 'q'
    });

    this.board.position(this.game.fen(), true); // Animate the move
    this.highlightMove(result);
    this.currentMoveIndex++;

    if (this.isPuzzleSolved()) {
      this.onPuzzleSolvedCallback();
    }
  }

  isPuzzleSolved() {
    return this.currentMoveIndex >= this.puzzleMoves.length;
  }

  highlightSquare(square) {
    $(`#${this.boardConfig.boardId} .square-${square}`).addClass('highlight-square');
  }

  removeHighlights() {
    $(`#${this.boardConfig.boardId} .square-55d63`).removeClass('highlight-square');
  }

  removeMoveHighlights() {
    $(`#${this.boardConfig.boardId} .square-55d63`).removeClass('highlight-move');
  }

  highlightMove(move) {
    this.removeMoveHighlights();
    $(`#${this.boardConfig.boardId} .square-${move.from}`).addClass('highlight-move');
    $(`#${this.boardConfig.boardId} .square-${move.to}`).addClass('highlight-move');
  }

  setPosition(fen) {
    this.game.load(fen);
    this.board.position(fen);
  }

  reset() {
    this.game.reset();
    this.board.start();
    this.puzzleMoves = [];
    this.currentMoveIndex = 0;
  }
}

window.ChessGame = ChessGame;
</file>

<file path="scripts/puzzle-generator.js">
class PuzzleGenerator {
  constructor() {
    this.puzzles = [];
    this.currentPuzzle = null;
    this.usedPuzzles = new Set();
    this.loaded = false;

    this.loadPuzzles();
  }

  loadPuzzles() {
    return fetch(chrome.runtime.getURL('Puzzles/puzzles.json'))
      .then(response => response.json())
      .then(data => {
        this.puzzles = data;
        this.loaded = true;
        console.log('Puzzles loaded:', this.puzzles.length);
      })
      .catch(err => {
        console.error('Failed to load puzzles:', err);
        this.loaded = false;
      });
  }

  async getRandomPuzzle() {
    if (!this.loaded) {
      await this.loadPuzzles();
    }

    console.log('Puzzles available:', this.puzzles.length);
    if (this.puzzles.length === 0) {
      this.resetPuzzles();
    }

    if (this.puzzles.length === 0) {
      throw new Error('No puzzles available');
    }

    const index = Math.floor(Math.random() * this.puzzles.length);
    this.currentPuzzle = this.puzzles.splice(index, 1)[0];
    this.usedPuzzles.add(this.currentPuzzle);
    console.log('Current puzzle:', this.currentPuzzle);
    console.log('Moves:', this.currentPuzzle.Moves);
    return {
      fen: this.currentPuzzle.FEN,
      moves: this.currentPuzzle.Moves.split(' '),
      tags: this.currentPuzzle.Themes.split(' '),
      elo: this.currentPuzzle.Rating
    };
  }

  resetPuzzles() {
    this.puzzles = [...this.usedPuzzles];
    this.usedPuzzles.clear();
  }

  checkSolution(moves) {
    if (!this.currentPuzzle) return false;

    const solutionMoves = this.currentPuzzle.Moves.split(' ');
    return moves.join(' ') === solutionMoves.join(' ');
  }

  getHint() {
    if (!this.currentPuzzle) return null;

    const firstMove = this.currentPuzzle.Moves.split(' ')[0];
    return `Try moving from ${firstMove.slice(0, 2)} to ${firstMove.slice(2, 4)}`;
  }
}

window.PuzzleGenerator = PuzzleGenerator;
</file>

<file path="settings/settings.css">
body {
  font-family: Arial, sans-serif;
  line-height: 1.6;
  color: #333;
  background-color: #f4f4f4;
  margin: 0;
  padding: 20px;
}

.container {
  max-width: 800px;
  margin: 0 auto;
  background-color: #fff;
  padding: 20px;
  border-radius: 5px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

h1 {
  color: #fff;
  background-color: #4a90e2;
  padding: 20px;
  margin: -20px -20px 20px -20px;
  border-radius: 5px 5px 0 0;
}

.icon {
  margin-right: 10px;
}

.info-bar {
  background-color: #e8f4fd;
  padding: 15px;
  margin-bottom: 20px;
  border-radius: 5px;
  border-left: 5px solid #4a90e2;
}

.setting {
  margin-bottom: 20px;
  padding-bottom: 20px;
  border-bottom: 1px solid #eee;
}

.setting-text h2 {
  margin: 0;
  font-size: 18px;
}

.setting-text p {
  margin: 5px 0 0 0;
  color: #666;
}

.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
}

input:checked + .slider {
  background-color: #4a90e2;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}

.global-controls {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  background-color: #f9f9f9;
  padding: 15px;
  border-radius: 5px;
}

.global-controls label {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.global-controls input {
  width: 60px;
  padding: 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
}

.add-website {
  display: flex;
}

#websiteInput {
  flex-grow: 1;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px 0 0 5px;
}

#addWebsite {
  padding: 10px 20px;
  background-color: #4a90e2;
  color: white;
  border: none;
  border-radius: 0 5px 5px 0;
  cursor: pointer;
}

.website-list {
  list-style-type: none;
  padding: 0;
}

.website-list li {
  background-color: #f9f9f9;
  padding: 15px;
  margin-bottom: 10px;
  border-radius: 5px;
}

.website-list h3 {
  margin-top: 0;
  color: #4a90e2;
}

.website-controls {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
}

.website-controls label {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.website-controls input {
  width: 60px;
  padding: 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
}

.remove-website {
  grid-column: 1 / -1;
  background-color: #e74c3c;
  color: white;
  border: none;
  padding: 5px 10px;
  border-radius: 3px;
  cursor: pointer;
}

.footer {
  margin-top: 20px;
  text-align: center;
  color: #666;
}

a {
  color: #4a90e2;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}
</file>

<file path="settings/settings.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Settings - Chess Puzzle Extension</title>
  <link rel="stylesheet" href="settings.css">
</head>
<body>
  <div class="container">
    <h1><span class="icon">⚙️</span> Chess Puzzle Extension Settings</h1>
    
    <div class="info-bar">
      This extension presents chess puzzles that increase in difficulty as you use a website. Solve puzzles to gain time, but be careful - mistakes will cost you!
    </div>
    
    <div class="setting">
      <div class="setting-text">
        <h2>Show timer</h2>
        <p>Display a timer for time left on websites</p>
      </div>
      <label class="switch">
        <input type="checkbox" id="showTimer" checked>
        <span class="slider round"></span>
      </label>
    </div>
    
    <div class="setting">
      <div class="setting-text">
        <h2>Global Settings</h2>
        <p>Configure global puzzle and time settings.</p>
      </div>
      <div id="globalSettings" class="global-controls">
        <label>Min ELO: <input type="number" id="minElo" min="500" max="3000"></label>
        <label>Max ELO: <input type="number" id="maxElo" min="500" max="3000"></label>
        <label>Time bonus (seconds): <input type="number" id="timeBonus" min="0" max="60"></label>
        <label>Wrong move penalty (seconds): <input type="number" id="wrongMovePenalty" min="0" max="60"></label>
        <label>Hint penalty (seconds): <input type="number" id="hintPenalty" min="0" max="60"></label>
        <label>Skip penalty (seconds): <input type="number" id="skipPenalty" min="0" max="60"></label>
      </div>
    </div>
    
    <div class="setting">
      <div class="setting-text">
        <h2>Add website</h2>
        <p>Add a new website to the list below</p>
      </div>
      <div class="add-website">
        <input type="text" id="websiteInput" placeholder="Enter website URL">
        <button id="addWebsite">Add Website</button>
      </div>
    </div>
    
    <div class="setting">
      <div class="setting-text">
        <h2>Website Settings</h2>
        <p>Configure session settings for each website.</p>
      </div>
      <ul id="websiteList" class="website-list"></ul>
    </div>
    
    <div class="footer">
      Enjoying the Chess Puzzle Extension? <a href="#">Please leave us a rating and review</a>
    </div>
  </div>
  <script src="settings.js"></script>
</body>
</html>
</file>

<file path="settings/settings.js">
document.addEventListener('DOMContentLoaded', loadSettings);
document.getElementById('addWebsite').addEventListener('click', addWebsite);

function loadSettings() {
  chrome.storage.sync.get(['websites', 'showTimer', 'globalSettings'], (data) => {
    if (data.websites) {
      // Filter out invalid entries
      const validWebsites = data.websites.filter(site => 
        site && typeof site === 'object' && site.url && typeof site.url === 'string' && site.url !== 'undefined'
      );
      
      // If we filtered out any invalid entries, update the storage
      if (validWebsites.length !== data.websites.length) {
        chrome.storage.sync.set({websites: validWebsites}, () => {
          console.log('Removed invalid website entries');
        });
      }
      
      updateWebsiteList(validWebsites);
    }
    if (data.showTimer !== undefined) document.getElementById('showTimer').checked = data.showTimer;
    if (data.globalSettings) updateGlobalSettings(data.globalSettings);
    else initializeGlobalSettings();
  });
}

function initializeGlobalSettings() {
  const defaultGlobalSettings = {
    minElo: 800,
    maxElo: 2000,
    timeBonus: 2,
    wrongMovePenalty: 1,
    hintPenalty: 1,
    skipPenalty: 2
  };
  chrome.storage.sync.set({globalSettings: defaultGlobalSettings}, () => {
    updateGlobalSettings(defaultGlobalSettings);
  });
}

function updateGlobalSettings(settings) {
  Object.keys(settings).forEach(key => {
    const element = document.getElementById(key);
    if (element) element.value = settings[key];
  });
}

function addWebsite() {
  const input = document.getElementById('websiteInput');
  const website = input.value.trim();
  if (website) {
    chrome.storage.sync.get({websites: []}, (data) => {
      if (!data.websites.some(site => site.url === website)) {
        data.websites.push({
          url: website,
          sessions: 3,
          timePerSession: 30
        });
        chrome.storage.sync.set({websites: data.websites}, () => {
          updateWebsiteList(data.websites);
          input.value = '';
        });
      } else {
        alert('This website is already in the list.');
      }
    });
  }
}

function updateWebsiteList(websites) {
  const list = document.getElementById('websiteList');
  list.innerHTML = '';
  websites.forEach(site => {
    const li = document.createElement('li');
    li.innerHTML = `
      <h3>${site.url}</h3>
      <div class="website-controls">
        <label>Sessions per day: <input type="number" class="sessions" value="${site.sessions}" min="1" max="10"></label>
        <label> per session: <input type="number" class="timePerSession" value="${site.timePerSession}" min="1" max="120"></label>
        <button class="remove-website" data-site="${site.url}">Remove</button>
      </div>
    `;
    list.appendChild(li);
  });
  
  // Add event listeners to remove buttons and input fields
  document.querySelectorAll('.remove-website').forEach(btn => {
    btn.addEventListener('click', function() {
      removeWebsite(this.getAttribute('data-site'));
    });
  });

  document.querySelectorAll('.website-controls input').forEach(input => {
    input.addEventListener('change', function() {
      updateWebsiteSettings(this);
    });
  });
}

function removeWebsite(siteUrl) {
  chrome.storage.sync.get({websites: []}, (data) => {
    const updatedWebsites = data.websites.filter(site => site.url !== siteUrl);
    chrome.storage.sync.set({websites: updatedWebsites}, () => {
      updateWebsiteList(updatedWebsites);
    });
  });
}

function updateWebsiteSettings(input) {
  const li = input.closest('li');
  const siteUrl = li.querySelector('h3').textContent;
  const newValue = parseInt(input.value);
  const settingName = input.className;

  chrome.storage.sync.get({websites: []}, (data) => {
    const updatedWebsites = data.websites.map(site => {
      if (site.url === siteUrl) {
        site[settingName] = newValue;
      }
      return site;
    });
    chrome.storage.sync.set({websites: updatedWebsites});
  });
}

// Save showTimer setting when toggled
document.getElementById('showTimer').addEventListener('change', function() {
  chrome.storage.sync.set({showTimer: this.checked});
});

// Save global settings when changed
document.querySelectorAll('#globalSettings input').forEach(input => {
  input.addEventListener('change', function() {
    saveGlobalSettings();
  });
});

function saveGlobalSettings() {
  const globalSettings = {
    minElo: parseInt(document.getElementById('minElo').value),
    maxElo: parseInt(document.getElementById('maxElo').value),
    timeBonus: parseInt(document.getElementById('timeBonus').value),
    wrongMovePenalty: parseInt(document.getElementById('wrongMovePenalty').value),
    hintPenalty: parseInt(document.getElementById('hintPenalty').value),
    skipPenalty: parseInt(document.getElementById('skipPenalty').value)
  };
  chrome.storage.sync.set({globalSettings});
}
</file>

</repository_files>
