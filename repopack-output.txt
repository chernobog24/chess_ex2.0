<summary>

<header>
Repopack Output File
This file was generated by Repopack on: 2024-11-07T05:56:00.186Z
</header>

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository structure
3. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the file path attributes to distinguish
  between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.


</notes>

<additional_info>
For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</summary>

<repository_structure>
.gitignore
background/service-worker.js
manifest.json
overlay/overlay.css
overlay/overlay.html
overlay/overlay.js
overlay/timerBar.js
popup/popup.css
popup/popup.html
popup/popup.js
README.md
scripts/chess-game.js
scripts/puzzle-generator.js
settings/settings.css
settings/settings.html
settings/settings.js
</repository_structure>

<repository_files>

<file path=".gitignore">
#Ignore repopack
repopack-output.txt
# Ignore Puzzles folder
Puzzles/

# Ignore common files
.DS_Store
Thumbs.db

# Ignore node modules if you decide to use npm in the future
node_modules/

# Ignore any log files
*.log

# Ignore .vscode settings
.vscode/

# Ignore any sensitive or environment-specific files
config.json
secrets.json
</file>

<file path="background/service-worker.js">
// State management
const state = {
  websiteTimers: {},
  settings: {
    websites: [],
    globalSettings: {
      minElo: 1000,
      maxElo: 1900,
      timeBonus: 2,
      wrongMovePenalty: 1,
      hintPenalty: 1,
      skipPenalty: 2
    }
  },
  sessions: {}
};

// Initialization
chrome.runtime.onInstalled.addListener(initializeExtension);

// Event listeners
chrome.tabs.onUpdated.addListener(handleTabUpdate);
chrome.tabs.onRemoved.addListener(handleTabRemoval);
chrome.storage.onChanged.addListener(handleStorageChange);
chrome.runtime.onMessage.addListener(handleMessage);

// Initialization function
function initializeExtension() {
  console.log('Extension installed. Loading settings...');
  loadSettings();
}

// Settings management
function loadSettings() {
  chrome.storage.sync.get(['websites', 'globalSettings'], (data) => {
    if (data.websites) state.settings.websites = data.websites;
    if (data.globalSettings) state.settings.globalSettings = data.globalSettings;
    console.log('Settings loaded:', state.settings);

    // Load sessions from local storage
    chrome.storage.local.get(['sessions'], (result) => {
      if (result.sessions) {
        state.sessions = result.sessions;
        console.log('Sessions loaded from storage');
      } else {
        console.log('No saved sessions found, initializing empty sessions');
      }

      // Initialize or update session counters
      state.settings.websites.forEach(website => {
        if (!state.sessions[website.url]) {
          state.sessions[website.url] = {
            count: 0,
            lastResetDate: new Date().toDateString()
          };
        }
      });

      console.log('Sessions initialized:', state.sessions);
    });
  });
}

// Tab management
function handleTabUpdate(tabId, changeInfo, tab) {
  if (changeInfo.status === 'complete' && tab.url) {
    console.log(`Tab updated: ${tabId}, URL: ${tab.url}`);
    const website = findMatchingWebsite(tab.url);
    if (website) {
      console.log(`Monitored website detected: ${website.url}`);
      updateSessionCount(website);
      checkPuzzleRequirement(tabId, website);
      updateTimerBar(tabId, website);
    }
  }
}

function findMatchingWebsite(url) {
  return state.settings.websites.find(site => url.includes(site.url));
}

function updateSessionCount(website) {
  const today = new Date().toDateString();
  const websiteTimer = state.websiteTimers[website.url];

  // Only update if there's no active timer
  if (!websiteTimer || websiteTimer.status !== 'active') {
    if (state.sessions[website.url].lastResetDate !== today) {
      state.sessions[website.url] = {
        count: 0,
        lastResetDate: today
      };
    }
    if (state.sessions[website.url].count < website.sessions) {
      state.sessions[website.url].count++;
    }

    // Save the updated state to Chrome's storage
    chrome.storage.local.set({ sessions: state.sessions }, () => {
      if (chrome.runtime.lastError) {
        console.error('Error saving sessions:', chrome.runtime.lastError);
      } else {
        console.log('Sessions saved successfully');
      }
    });
  }
}
// Puzzle management
function checkPuzzleRequirement(tabId, website) {
  console.log(`Checking puzzle requirement for website: ${website.url}`);
  const timer = state.websiteTimers[website.url];
  if (!timer || timer.status === 'expired') {
    console.log(`Puzzle required for website ${website.url}. Reason: ${!timer ? 'New session' : 'Session expired'}`);
    sendOverlayMessage(tabId, "start", website.url);
  } else if (timer.status === 'active') {
    console.log(`Active session for website ${website.url}. No puzzle required.`);
  }
}

function calculateCurrentElo(website) {
  const { minElo, maxElo } = state.settings.globalSettings;
  const sessionProgress = state.sessions[website.url].count / website.sessions;
  console.log(`Session progress for ${website.url}: ${sessionProgress}`)
  console.log(`Elo set to ${minElo + (maxElo - minElo) * sessionProgress}`)
  return Math.round(minElo + (maxElo - minElo) * sessionProgress);
}

// Timer management
function updateTimerBar(tabId, website) {
  const remainingTime = getTimerStatus(website.url);
  chrome.tabs.sendMessage(tabId, {
    target: 'timerBar',
    action: "updateTimerBar",
    timeLeft: remainingTime * 60, // Convert minutes to seconds
    totalTime: website.timePerSession * 60
  });
}
function startTimer(website) {
  console.log(`Starting timer for website: ${website.url}`);
  if (state.websiteTimers[website.url]) {
    console.log(`Clearing existing timer for website ${website.url}`);
    clearTimeout(state.websiteTimers[website.url].timer);
  }
  
  state.websiteTimers[website.url] = {
    status: 'active',
    startTime: Date.now(),
    timer: setTimeout(() => {
      console.log(`Timer expired for website ${website.url}`);
      state.websiteTimers[website.url].status = 'expired';
      notifyAllTabs(website.url);
    }, website.timePerSession * 60 * 1000)
  };
  console.log(`Timer set for ${website.timePerSession} minutes`);
}

function getTimerStatus(websiteUrl) {
  const timer = state.websiteTimers[websiteUrl];
  if (!timer || timer.status !== 'active') {
    console.log(`No active timer for website ${websiteUrl}`);
    return 0;
  }
  const website = findMatchingWebsite(websiteUrl);
  if (!website) return 0;

  const elapsedTime = Date.now() - timer.startTime;
  const remainingTime = Math.max(0, Math.round((website.timePerSession * 60 * 1000 - elapsedTime) / (60 * 1000)));
  console.log(`Timer status for website ${websiteUrl}: ${remainingTime} minutes remaining`);
  return remainingTime;
}

// Notification management
function sendOverlayMessage(tabId, reason, websiteUrl) {
  const website = findMatchingWebsite(websiteUrl);
  if (website) {
    const currentElo = calculateCurrentElo(website);
    const overlayData = {
      currentElo,
      currentSession: state.sessions[website.url].count,
      maxSessions: website.sessions,
      globalSettings: state.settings.globalSettings,
      websiteSettings: website
    };
    chrome.tabs.sendMessage(tabId, { 
      target: 'overlay', 
      action: "showOverlay", 
      reason: reason,
      data: overlayData
    });
  }
}

function notifyAllTabs(websiteUrl) {
  chrome.tabs.query({url: `*://${websiteUrl}/*`}, (tabs) => {
    tabs.forEach(tab => {
      sendOverlayMessage(tab.id, "timeUp", websiteUrl);
    });
  });
}

// Message handling
function handleMessage(request, sender, sendResponse) {
  console.log('Message received:', request);
  switch (request.action) {
    case "overlayCompleted":
      handleOverlayCompleted(sender, request, sendResponse);
      break;
    case "getTimerStatus":
      handleGetTimerStatus(sendResponse);
      break;
    case "triggerOverlay":
      handleTriggerOverlay(sendResponse);
      break;
  }
  return true;
}

function handleOverlayCompleted(sender, request, sendResponse) {
  if (sender.tab && request.solved) {
    const websiteUrl = new URL(sender.tab.url).hostname;
    const website = findMatchingWebsite(websiteUrl);
    if (website) {
      console.log(`Puzzle solved for website: ${website.url}`);
      startTimer(website);
      updateTimerBar(sender.tab.id, website);
      sendResponse({ status: "Timer started" });
    }
  }
}

function handleGetTimerStatus(sendResponse) {
  chrome.tabs.query({active: true, currentWindow: true}, ([tab]) => {
    if (tab) {
      const websiteUrl = new URL(tab.url).hostname;
      const website = findMatchingWebsite(websiteUrl);
      if (website) {
        const remainingTime = getTimerStatus(website.url);
        console.log(`Timer status requested for website ${website.url}. Remaining time: ${remainingTime} minutes`);
        sendResponse({ status: `Time remaining: ${remainingTime} minutes` });
      } else {
        sendResponse({ status: "No active timer for this website" });
      }
    } else {
      sendResponse({ status: "No active tab" });
    }
  });
}

function handleTriggerOverlay(sendResponse) {
  chrome.tabs.query({active: true, currentWindow: true}, ([tab]) => {
    if (tab) {
      const websiteUrl = new URL(tab.url).hostname;
      const website = findMatchingWebsite(websiteUrl);
      if (website) {
        sendOverlayMessage(tab.id, "start", websiteUrl);
        sendResponse({ status: "Overlay triggered" });
      } else {
        sendResponse({ status: "Website not monitored" });
      }
    } else {
      sendResponse({ status: "No active tab" });
    }
  });
}

// Tab removal handling
function handleTabRemoval(tabId, removeInfo) {
  console.log(`Tab ${tabId} removed`);
  chrome.tabs.query({}, (tabs) => {
    Object.keys(state.websiteTimers).forEach(websiteUrl => {
      if (!tabs.some(tab => tab.url.includes(websiteUrl))) {
        console.log(`Cleaning up timer for website ${websiteUrl}`);
        clearTimeout(state.websiteTimers[websiteUrl].timer);
        delete state.websiteTimers[websiteUrl];
      }
    });
  });
}

// Storage change handling
function handleStorageChange(changes, namespace) {
  for (let key in changes) {
    let storageChange = changes[key];
    console.log('Storage key "%s" in namespace "%s" changed. ' +
                'Old value was "%s", new value is "%s".',
                key,
                namespace,
                storageChange.oldValue,
                storageChange.newValue);
    
    if (key === 'websites' || key === 'globalSettings') {
      state.settings[key] = storageChange.newValue;
    }
  }
  console.log('Updated settings:', state.settings);
}

console.log('Service worker initialized');
</file>

<file path="manifest.json">
{
    "manifest_version": 3,
    "name": "Chessboard Popup",
    "version": "2.0",
    "description": "Chess puzzles and timed website breaks with interactive chessboard",
    "icons": {
      "16": "images/icon-16.png",
      "32": "images/icon-32.png",
      "48": "images/icon-48.png",
      "128": "images/icon-128.png"
    },
    "action": {
      "default_popup": "popup/popup.html",
      "default_icon": {
        "16": "images/icon-16.png",
        "32": "images/icon-32.png",
        "48": "images/icon-48.png",
        "128": "images/icon-128.png"
      }
    },
    "permissions": [
      "storage",
      "alarms",
      "activeTab",
      "tabs"
    ],
    "host_permissions": [
      "<all_urls>"
    ],
    "background": {
      "service_worker": "background/service-worker.js"
    },
    "options_page": "settings/settings.html",
    "content_scripts": [
      {
        "matches": ["<all_urls>"],
        "js": [
          "libs/jquery.min.js",
          "libs/chessboardjs-1.0.0/js/chessboard-1.0.0.min.js",
          "libs/chess.js",
          "scripts/chess-game.js",
          "scripts/puzzle-generator.js",
          "scripts/timer.js",
          "overlay/timerBar.js",
          "overlay/overlay.js"
        ],
        "css": [
          "libs/chessboardjs-1.0.0/css/chessboard-1.0.0.min.css",
          "styles/chessboard.css"
        ]
      }
    ],
    "web_accessible_resources": [
      {
        "resources": [
          "libs/chessboardjs-1.0.0/img/chesspieces/wikipedia/*",
          "Puzzles/puzzles.json",
          "overlay/overlay.html",
          "images/solved.webm",
          "overlay/overlay.css"
        ],
        "run_at": "document_end",
        "matches": ["<all_urls>"]
      }
    ]
  }
</file>

<file path="overlay/overlay.css">
.chess-puzzle-overlay #chessOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.chess-puzzle-overlay #puzzleContainer {
  background: white;
  padding: 30px;
  border-radius: 15px;
  box-shadow: 0 0 20px rgba(0,0,0,0.3);
  display: flex;
  flex-direction: column;
  align-items: center;
}

.chess-puzzle-overlay #sessionInfo {
  font-size: 16px;
  margin-bottom: 10px;
  color: #333;
  text-align: center;
}

.chess-puzzle-overlay #timerDisplay {
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 20px;
  color: #333;
}

.chess-puzzle-overlay #chessboard {
  width: 600px;
  height: 600px;
  margin-bottom: 20px;
}

.chess-puzzle-overlay #puzzleInfo {
  text-align: center;
  margin-top: 20px;
  font-family: Arial, sans-serif;
}

.chess-puzzle-overlay #puzzlePrompt {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 10px;
}

.chess-puzzle-overlay #puzzleElo {
  font-size: 16px;
  color: #666;
  margin-bottom: 10px;
}

.chess-puzzle-overlay .button {
  padding: 10px 20px;
  font-size: 16px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.chess-puzzle-overlay .button:hover {
  background-color: #45a049;
}

.chess-puzzle-overlay .button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.chess-puzzle-overlay #closeOverlay {
  margin-top: 20px;
  margin-bottom: 10px;
}

.chess-puzzle-overlay #controlBar {
  display: flex;
  justify-content: space-between;
  width: 100%;
  margin-top: 20px;
}

.chess-puzzle-overlay #controlBar .button {
  flex: 1;
  margin: 0 5px;
}

.piece-417db {
  z-index: 10000 !important;
}

.chess-puzzle-overlay .highlight-green {
  box-shadow: inset 0 0 3px 3px green;
}

.chess-puzzle-overlay .highlight-move {
  background-color: rgba(255, 255, 0, 0.5) !important;
}

.chess-puzzle-overlay .highlight-square::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 25%;
  height: 25%;
  background-color: rgba(10, 128, 10, 0.5);
  border-radius: 50%;
  z-index: 10;
}

.chess-puzzle-overlay #solvedAnimation {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10001;
  display: none;
  width: 100px;
  height: auto;
}
</file>

<file path="overlay/overlay.html">
<div class="chess-puzzle-overlay">
  <div id="chessOverlay">
    <div id="puzzleContainer">
      <div id="timerDisplay"></div>
      <div id="sessionInfo"></div>
      <div id="chessboard"></div>
      <div id="puzzleInfo">
        <p id="puzzlePrompt">Solve the puzzle to continue browsing</p>
        <p id="puzzleElo"></p>
      </div>
      <button id="closeOverlay" class="button" disabled>Close</button>
      <div id="controlBar">
        <button id="showHint" class="button">Show Hint</button>
        <button id="undoMove" class="button">Undo</button>
        <button id="redoMove" class="button">Redo</button>
        <button id="skipPuzzle" class="button">Skip Puzzle</button>
      </div>
    </div>
    <video id="solvedAnimation" muted></video>
  </div>
</div>
</file>

<file path="overlay/overlay.js">
class ChessPuzzleOverlay {
  constructor(overlayData) {
    // Initialize core components
    this.chessGame = null;
    this.puzzleGenerator = null;
    this.solvedAnimationUrl = chrome.runtime.getURL('images/solved.webm');
    
    // Set up data from service worker
    this.currentElo = overlayData.currentElo;
    this.currentSession = overlayData.currentSession;
    this.maxSessions = overlayData.maxSessions;
    this.globalSettings = overlayData.globalSettings;
    this.websiteSettings = overlayData.websiteSettings;
    
    // Initialize state variables
    this.puzzleSolved = false;
    this.timeAdded = 0;
    this.timerInterval = null;
  }

  // Overlay Setup
  async injectOverlay() {
    console.log("Injecting overlay");
    try {
      const htmlUrl = chrome.runtime.getURL('overlay/overlay.html');
      const cssUrl = chrome.runtime.getURL('overlay/overlay.css');
      const [htmlResponse, cssResponse] = await Promise.all([
        fetch(htmlUrl),
        fetch(cssUrl)
      ]);
      const [htmlText, cssText] = await Promise.all([
        htmlResponse.text(),
        cssResponse.text()
      ]);

      const combinedHTML = `<style>${cssText}</style>${htmlText}`;
      document.body.insertAdjacentHTML('beforeend', combinedHTML);

      document.getElementById('solvedAnimation').src = this.solvedAnimationUrl;
      this.initializeOverlayElements();
    } catch (error) {
      console.error('Error injecting overlay:', error);
    }
  }

  initializeOverlayElements() {
    const elements = ['closeOverlay', 'showHint', 'undoMove', 'redoMove', 'skipPuzzle'];
    elements.forEach(id => {
      document.getElementById(id).addEventListener('click', this[id].bind(this));
    });
  }

  initializeOverlay() {
    this.chessGame = new ChessGame('chessboard', {
      boardId: 'chessboard',
      onMove: this.onMove.bind(this),
      onPuzzleSolved: this.onPuzzleSolved.bind(this),
      onWrongMove: this.onWrongMove.bind(this)
    });
    this.chessGame.init();
    this.puzzleGenerator = new PuzzleGenerator();
    this.updateSessionInfo();
  }

  async showOverlay() {
    await this.injectOverlay();
    this.initializeOverlay();
    document.getElementById('chessOverlay').style.display = 'flex';
    this.loadNewPuzzle();
    this.startTimer();
  }
   
  // Puzzle Management
  async loadNewPuzzle() {
    try {
      const puzzle = await this.puzzleGenerator.getRandomPuzzle(this.currentElo);
      this.chessGame.setPuzzle(puzzle.fen, puzzle.moves);
      this.updatePuzzleInfo(puzzle);
    } catch (error) {
      console.error('Error loading puzzle:', error);
      document.getElementById('puzzlePrompt').textContent = 'Error loading puzzle. Please try again.';
    }
  }

  updatePuzzleInfo(puzzle) {
    document.getElementById('puzzlePrompt').textContent = `Solve this puzzle to continue browsing`;
    document.getElementById('puzzleElo').textContent = `Puzzle Elo: ${puzzle.elo}`;
  }

   
  // Timer Management
  startTimer() {
    this.timeAdded = 0;
    this.updateTimerDisplay();
    this.timerInterval = setInterval(() => this.updateTimerDisplay(), 1000);
  }

  updateTimerDisplay() {
    document.getElementById('timerDisplay').textContent = `Time added: ${this.timeAdded}s`;
  }

  applyTimeBonus(seconds) {
    this.timeAdded += seconds;
    this.updateTimerDisplay();
  }

  applyTimePenalty(seconds) {
    this.timeAdded = Math.max(0, this.timeAdded - seconds);
    this.updateTimerDisplay();
  }

   
  // Event Handlers
  onMove(move) {
    // Additional logic for move events can be added here
  }

  onWrongMove() {
    this.applyTimePenalty(this.globalSettings.wrongMovePenalty);
  }

  onPuzzleSolved() {
    this.endPuzzle(true);
    this.playSolvedAnimation();
    this.applyTimeBonus(this.globalSettings.timeBonus);
  }

   
  // User Actions
  closeOverlay() {
    if (this.puzzleSolved) {
      document.getElementById('chessOverlay').remove();
      chrome.runtime.sendMessage({
        target: 'background', 
        action: "overlayCompleted", 
        solved: true,
        timeAdded: this.timeAdded
      });
      chessPuzzleOverlay = null;
    }
  }

  showHint() {
    const hint = this.chessGame.getHint();
    this.applyTimePenalty(this.globalSettings.hintPenalty);
    // TODO: Implement hint display logic (e.g., highlight the piece to move)
  }

  undoMove() {
    this.chessGame.undoMove();
  }

  redoMove() {
    this.chessGame.redoMove();
  }

  skipPuzzle() {
    if (!this.puzzleSolved) {
      this.applyTimePenalty(this.globalSettings.skipPenalty);
    }
    this.loadNewPuzzle();
  }

  // UI Updates
  updateSessionInfo() {
    const sessionInfoElement = document.getElementById('sessionInfo');
    if (sessionInfoElement) {
      sessionInfoElement.textContent = `Session ${this.currentSession}/${this.maxSessions} | Current ELO: ${this.currentElo}`;
    }
  }

  playSolvedAnimation() {
    const video = document.getElementById('solvedAnimation');
    video.style.display = 'block';
    video.currentTime = 0;
    video.play().then(() => {
      video.onended = () => {
        video.style.display = 'none';
      };
    }).catch(error => {
      console.error('Error playing video:', error);
      video.style.display = 'none';
    });
  }

  endPuzzle(solved) {
    clearInterval(this.timerInterval);
    this.puzzleSolved = solved;
    document.getElementById('closeOverlay').disabled = false;
    document.getElementById('puzzlePrompt').textContent = solved 
      ? 'Puzzle solved! You can close the overlay.' 
      : 'Time\'s up! You can close the overlay.';
    if (solved) {
      this.playSolvedAnimation();
    }
  }
}

 
// Global Event Listener
let chessPuzzleOverlay = null;

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.target === 'overlay') {
    console.log("Received message by overlay:", request);
    if (request.action === "showOverlay") {
      if (chessPuzzleOverlay) {
        chessPuzzleOverlay.closeOverlay();
      }
      chessPuzzleOverlay = new ChessPuzzleOverlay(request.data);
      chessPuzzleOverlay.showOverlay();
    }
  }
});

console.log("Overlay script ready");
</file>

<file path="overlay/timerBar.js">
// overlay/timerBar.js

class TimerBar {
    constructor() {
        this.barElement = null;
        this.timeLeft = 0;
        this.totalTime = 0;
        this.isVisible = false;
        this.lastUpdateTime = 0;
        this.BAR_HEIGHT = '20px';  // Define bar height as a constant
      }
    
      init() {
        // Only create bar if we're on a monitored website
        chrome.storage.sync.get(['websites'], (data) => {
            if (data.websites) {
                const currentUrl = window.location.hostname;
                const isMonitored = data.websites.some(site => 
                    currentUrl.includes(site.url)
                );
                
                if (isMonitored) {
                    this.setupMessageListener();
                    this.createElements();
                }
            }
        });
        console.log('TimerBar initialized');
    }

      createElements() {
        if (!this.barElement) {
          this.barElement = document.createElement('div');
          this.barElement.id = 'chess-puzzle-timer-bar';
          this.barElement.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: ${this.BAR_HEIGHT};
            background-color: #4CAF50;
            z-index: 9999999;
            transition: width 0.1s linear;
          `;
          document.body.insertBefore(this.barElement, document.body.firstChild);
        }
    
        // Add CSS variable for width
        document.documentElement.style.setProperty('--timer-width', '100%');
        this.barElement.style.width = 'var(--timer-width)';
      }

    setupMessageListener() {
        chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
        if (request.target !== 'timerBar') return;
        console.log('Received message in timerBar:', request);
        switch (request.action) {
            case 'updateTimerBar':
            this.updateTimerBar(request.timeLeft, request.totalTime);
            break;
            case 'showTimer':
            this.showTimer();
            break;
            case 'hideTimer':
            this.hideTimer();
            break;
        }
        });
    }

    updateTimerBar(timeLeft, totalTime) {
        this.timeLeft = timeLeft;
        this.totalTime = totalTime;
        this.lastUpdateTime = Date.now();
        this.updateBarDisplay();
    }

    updateBarDisplay() {
        if (this.barElement) {
        const now = Date.now();
        const elapsedSinceUpdate = (now - this.lastUpdateTime) / 1000; // in seconds
        const currentTimeLeft = Math.max(0, this.timeLeft - elapsedSinceUpdate);
        const percentage = (currentTimeLeft / this.totalTime) * 100;
        this.barElement.dataset.width = `${percentage}%`;
        document.documentElement.style.setProperty('--timer-width', `${percentage}%`);

        if (currentTimeLeft > 0) {
            requestAnimationFrame(() => this.updateBarDisplay());
        }
        }
    }

    showTimer() {
        this.isVisible = true;
        if (this.barElement) {
          this.barElement.style.display = 'block';
          document.body.style.paddingTop = this.BAR_HEIGHT;
        }
      }
    
    hideTimer() {
    this.isVisible = false;
    if (this.barElement) {
        this.barElement.style.display = 'none';
        document.body.style.paddingTop = '0px';
    }
    }
}
  
// Initialize the timer bar
const timerBar = new TimerBar();
timerBar.init();
</file>

<file path="popup/popup.css">
body {
    width: 200px;
    padding: 10px;
  }
  
  button {
    width: 100%;
    margin: 5px 0;
    padding: 5px;
  }
  
  #timerStatus {
    margin-top: 10px;
    text-align: center;
  }
</file>

<file path="popup/popup.html">
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="popup.css">
</head>
<body>
  <h1>Chessboard Popup</h1>
  <button id="settingsBtn">Settings</button>
  <button id="triggerOverlayBtn">Show Chess Puzzle</button>
  <div id="timerStatus"></div>
  <script src="popup.js"></script>
</body>
</html>
</file>

<file path="popup/popup.js">
document.getElementById('settingsBtn').addEventListener('click', () => chrome.runtime.openOptionsPage());

document.getElementById('triggerOverlayBtn').addEventListener('click', () => 
  chrome.runtime.sendMessage({action: "triggerOverlay"}));

chrome.runtime.sendMessage({action: "getTimerStatus"}, (response) => {
  document.getElementById('timerStatus').textContent = response.status;
});
</file>

<file path="README.md">
# Chess Puzzle Extension

This Chrome extension provides an interactive chess puzzle solving experience. It helps users improve their chess skills by presenting them with timed puzzles during their browsing sessions.

## Features

- Timed chess puzzles that appear as overlays on specified websites
- Customizable timer duration and website list
- Interactive chessboard with drag-and-drop functionality
- Puzzle difficulty levels (Easy, Medium, Hard)
- Hint system for challenging puzzles
- Settings page for customization

## Project Structure

- `manifest.json`: The extension manifest file
- `background/`: Contains the service worker for the extension
  - `service-worker.js`: Manages the background processes, including timers and messaging
- `images/`: Icon images for the extension
- `overlay/`: Contains the overlay functionality
  - `overlay.js`: Manages the chess puzzle overlay display and interaction
- `popup/`: Contains the extension popup
  - `popup.html`: HTML structure for the popup
  - `popup.css`: Styles for the popup
  - `popup.js`: JavaScript for popup functionality
- `scripts/`: Contains the main chess game and puzzle generator scripts
  - `chess-game.js`: Implements the chess game logic
  - `puzzle-generator.js`: Manages puzzle generation and difficulty
- `settings/`: Contains the settings page
  - `settings.html`: HTML structure for the settings page
  - `settings.css`: Styles for the settings page
  - `settings.js`: JavaScript for settings functionality
- `styles/`: Contains additional styles
  - `chessboard.css`: Styles for the chessboard

## Libraries

The `libs/` directory is not included in this repository. You need to obtain the following libraries:

- chess.js: A JavaScript chess library for chess move generation/validation, piece placement/movement, and check/checkmate/draw detection
- jquery.min.js: jQuery library for DOM manipulation
- chessboard.js (version 1.0.0): A JavaScript chessboard library

Place these files in the `libs/` directory.

## Puzzles

The `Puzzles/` directory is not included in this repository. To get the puzzles:

1. Download the puzzle database from Lichess: [Lichess Puzzle Database](https://database.lichess.org/#puzzles)
2. Format the puzzles according to the Lichess puzzle format. Each puzzle should have the following structure:
   ```json
   {
     "PuzzleId": "unique_id",
     "FEN": "chess_position_in_FEN_notation",
     "Moves": "move1 move2 move3 ...",
     "Rating": 1500,
     "Themes": "theme1 theme2 theme3"
   }
   ```
3. Use the `puzzleutils.py` script in the `Puzzles/` directory to process and prepare the puzzles for use in the extension. This script should convert the Lichess puzzle format into the format used by the extension.

## Setup

1. Clone this repository
2. Obtain the required libraries and place them in the `libs/` directory
3. Prepare the puzzles and place them in the `Puzzles/` directory
4. Load the extension in Chrome:
   - Go to `chrome://extensions/`
   - Enable "Developer mode"
   - Click "Load unpacked"
   - Select the directory containing this project

## Usage

1. Click on the extension icon in Chrome to open the popup
2. Use the Settings page to customize:
   - Websites where puzzles will appear
   - Timer duration for puzzles
3. Browse the web normally. When visiting a specified website, a chess puzzle will appear after the set duration
4. Solve the puzzle to continue browsing, or wait for the timer to expire

## Development

To modify or extend the extension:

1. Edit the relevant files in the project structure
2. For major changes, update the `manifest.json` file accordingly
3. Reload the extension in Chrome to see your changes

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is open source and available under the [MIT License](LICENSE).
</file>

<file path="scripts/chess-game.js">
class ChessGame {
  constructor(boardId, config = {}) {
    this.game = new Chess();
    this.boardConfig = {
      draggable: true,
      dropOffBoard: 'snapback',
      position: 'start',
      onDragStart: this.onDragStart.bind(this),
      onDrop: this.onDrop.bind(this),
      onSnapEnd: this.onSnapEnd.bind(this),
      onMouseoutSquare: this.onMouseoutSquare.bind(this),
      onMouseoverSquare: this.onMouseoverSquare.bind(this),
      pieceTheme: function(piece) {
        return chrome.runtime.getURL('libs/chessboardjs-1.0.0/img/chesspieces/wikipedia/' + piece + '.png');
      },
      ...config
    };
    this.board = null;
    this.onMoveCallback = config.onMove || (() => {});
    this.onPuzzleSolvedCallback = config.onPuzzleSolved || (() => {});
    this.onWrongMoveCallback = config.onWrongMove || (() => {});
    this.puzzleMoves = [];
    this.currentMoveIndex = 0;
    this.hintSquare = null;
    this.moveHistory = [];
    this.redoStack = [];
    this.solved = false;
  }

  // Initialization
  init() {
    this.board = Chessboard(this.boardConfig.boardId, this.boardConfig);
  }

  setPuzzle(fen, moves) {
    this.game.load(fen);
    this.board.position(fen);
    this.puzzleMoves = moves;
    this.currentMoveIndex = 0;
    this.moveHistory = [];
    this.redoStack = [];
    this.solved = false;
    this.makeNextMove(); // Make the initial opponent move
  }

  // Game State Management
  isPuzzleSolved() {
    return this.currentMoveIndex >= this.puzzleMoves.length;
  }

  isCorrectMove(move) {
    const expectedMove = this.puzzleMoves[this.currentMoveIndex];
    return move.from + move.to === expectedMove;
  }

  makeNextMove() {
    if (this.isPuzzleSolved()) return;

    const move = this.puzzleMoves[this.currentMoveIndex];
    const result = this.game.move({
      from: move.slice(0, 2),
      to: move.slice(2, 4),
      promotion: 'q'
    });

    this.board.position(this.game.fen(), true); // Animate the move
    this.highlightMove(result);
    this.currentMoveIndex++;
    this.moveHistory.push(result);
    this.redoStack = []; // Clear redo stack after a new move

    if (this.isPuzzleSolved() && !this.solved) {
      this.solved = true;
      this.onPuzzleSolvedCallback();
    }
  }

  // Move Handling
  onDragStart(source, piece) {
    if (this.game.game_over() || this.solved) return false;
    if ((this.game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (this.game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
  }

  onDrop(source, target) {
    // If we're not at the current move, reset to current position
    if (this.moveHistory.length !== this.currentMoveIndex) {
      this.resetToCurrentMove();
      return 'snapback';
    }

    const move = this.game.move({
      from: source,
      to: target,
      promotion: 'q'
    });
    
    if (move === null) return 'snapback';

    if (this.isCorrectMove(move)) {
      this.removeHighlights();
      this.highlightMove(move);
      this.currentMoveIndex++;
      this.moveHistory.push(move);
      this.redoStack = []; // Clear redo stack after a new move
      this.onMoveCallback(move);
      
      if (!this.isPuzzleSolved()) {
        setTimeout(() => this.makeNextMove(), 300);
      } else if (!this.solved) {
        this.solved = true;
        this.onPuzzleSolvedCallback();
      }
      
      return move;
    } else {
      this.game.undo();
      this.onWrongMoveCallback();
      return 'snapback';
    }
  }

  onSnapEnd() {
    this.board.position(this.game.fen());
  }

  undoMove() {
    if (this.moveHistory.length > 0) {
      const move = this.moveHistory.pop();
      this.game.undo();
      this.redoStack.push(move);
      this.board.position(this.game.fen());
      this.currentMoveIndex--;
      this.removeHighlights();
    }
  }

  redoMove() {
    if (this.redoStack.length > 0) {
      const move = this.redoStack.pop();
      this.game.move(move);
      this.moveHistory.push(move);
      this.board.position(this.game.fen());
      this.currentMoveIndex++;
      this.highlightMove(move);
    }
  }

  resetToCurrentMove() {
    this.game.reset();
    this.board.position('start');
    this.moveHistory.slice(0, this.currentMoveIndex).forEach(move => {
      this.game.move(move);
    });
    this.board.position(this.game.fen());
    this.removeHighlights();
  }

  // Board Interaction
  onMouseoverSquare(square) {
    if (this.solved) return;
    const moves = this.game.moves({ square: square, verbose: true });
    if (moves.length === 0) return;

    moves.forEach(move => this.highlightSquare(move.to));
  }

  onMouseoutSquare() {
    this.removeHighlights();
  }

  // Highlighting
  highlightSquare(square) {
    $(`#${this.boardConfig.boardId} .square-${square}`).addClass('highlight-square');
  }

  removeHighlights() {
    $(`#${this.boardConfig.boardId} .square-55d63`).removeClass('highlight-square');
    if (this.hintSquare) {
      $(`#${this.boardConfig.boardId} .square-${this.hintSquare}`).removeClass('highlight-hint');
      this.hintSquare = null;
    }
  }

  removeMoveHighlights() {
    $(`#${this.boardConfig.boardId} .square-55d63`).removeClass('highlight-move');
  }

  highlightMove(move) {
    this.removeMoveHighlights();
    $(`#${this.boardConfig.boardId} .square-${move.from}`).addClass('highlight-move');
    $(`#${this.boardConfig.boardId} .square-${move.to}`).addClass('highlight-move');
  }

  // Utility Functions
  setPosition(fen) {
    this.game.load(fen);
    this.board.position(fen);
  }

  reset() {
    this.game.reset();
    this.board.start();
    this.puzzleMoves = [];
    this.currentMoveIndex = 0;
    this.moveHistory = [];
    this.redoStack = [];
    this.solved = false;
  }

  getHint() {
    if (this.solved || this.currentMoveIndex >= this.puzzleMoves.length) return;

    const hintMove = this.puzzleMoves[this.currentMoveIndex];
    const fromSquare = hintMove.slice(0, 2);
    
    this.removeHighlights();
    $(`#${this.boardConfig.boardId} .square-${fromSquare}`).addClass('highlight-hint');
    this.hintSquare = fromSquare;
  }
}

window.ChessGame = ChessGame;
</file>

<file path="scripts/puzzle-generator.js">
class PuzzleGenerator {
  constructor() {
    this.puzzles = {};
    this.currentPuzzle = null;
    this.loaded = false;

    this.loadPuzzles();
  }

  loadPuzzles() {
    return fetch(chrome.runtime.getURL('Puzzles/puzzles.json'))
      .then(response => response.json())
      .then(data => {
        this.puzzles = data;
        this.loaded = true;
        console.log('Puzzles loaded:', Object.keys(this.puzzles).length, 'ELO ranges');
      })
      .catch(err => {
        console.error('Failed to load puzzles:', err);
        this.loaded = false;
      });
  }

  async getRandomPuzzle(elo) {
    if (!this.loaded) {
      await this.loadPuzzles();
    }

    const roundedElo = Math.floor(elo / 100) * 100;
    const eloRange = `${roundedElo}-${roundedElo + 99}`;

    if (!this.puzzles[eloRange] || this.puzzles[eloRange].length === 0) {
      throw new Error(`No puzzles available for ELO range ${eloRange}`);
    }

    const puzzlesInRange = this.puzzles[eloRange];
    const index = Math.floor(Math.random() * puzzlesInRange.length);
    this.currentPuzzle = puzzlesInRange[index];

    console.log('Current puzzle:', this.currentPuzzle);
    console.log('Moves:', this.currentPuzzle.Moves);

    return {
      fen: this.currentPuzzle.FEN,
      moves: this.currentPuzzle.Moves.split(' '),
      tags: this.currentPuzzle.Themes.split(' '),
      elo: this.currentPuzzle.Rating
    };
  }

  getHint() {
    if (!this.currentPuzzle) return null;

    const firstMove = this.currentPuzzle.Moves.split(' ')[0];
    return `Try moving from ${firstMove.slice(0, 2)} to ${firstMove.slice(2, 4)}`;
  }
}

window.PuzzleGenerator = PuzzleGenerator;
</file>

<file path="settings/settings.css">
body {
  font-family: Arial, sans-serif;
  line-height: 1.6;
  color: #333;
  background-color: #f4f4f4;
  margin: 0;
  padding: 20px;
}

.container {
  max-width: 800px;
  margin: 0 auto;
  background-color: #fff;
  padding: 20px;
  border-radius: 5px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

h1 {
  color: #fff;
  background-color: #4a90e2;
  padding: 20px;
  margin: -20px -20px 20px -20px;
  border-radius: 5px 5px 0 0;
}

.icon {
  margin-right: 10px;
}

.info-bar {
  background-color: #e8f4fd;
  padding: 15px;
  margin-bottom: 20px;
  border-radius: 5px;
  border-left: 5px solid #4a90e2;
}

.setting {
  margin-bottom: 20px;
  padding-bottom: 20px;
  border-bottom: 1px solid #eee;
}

.setting-text h2 {
  margin: 0;
  font-size: 18px;
}

.setting-text p {
  margin: 5px 0 0 0;
  color: #666;
}

.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
}

input:checked + .slider {
  background-color: #4a90e2;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}

.global-controls {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  background-color: #f9f9f9;
  padding: 15px;
  border-radius: 5px;
}

.global-controls label {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.global-controls input {
  width: 60px;
  padding: 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
}

.add-website {
  display: flex;
}

#websiteInput {
  flex-grow: 1;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px 0 0 5px;
}

#addWebsite {
  padding: 10px 20px;
  background-color: #4a90e2;
  color: white;
  border: none;
  border-radius: 0 5px 5px 0;
  cursor: pointer;
}

.website-list {
  list-style-type: none;
  padding: 0;
}

.website-list li {
  background-color: #f9f9f9;
  padding: 15px;
  margin-bottom: 10px;
  border-radius: 5px;
}

.website-list h3 {
  margin-top: 0;
  color: #4a90e2;
}

.website-controls {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
}

.website-controls label {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.website-controls input {
  width: 60px;
  padding: 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
}

.remove-website {
  grid-column: 1 / -1;
  background-color: #e74c3c;
  color: white;
  border: none;
  padding: 5px 10px;
  border-radius: 3px;
  cursor: pointer;
}

.footer {
  margin-top: 20px;
  text-align: center;
  color: #666;
}

a {
  color: #4a90e2;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}
</file>

<file path="settings/settings.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Settings - Chess Puzzle Extension</title>
  <link rel="stylesheet" href="settings.css">
</head>
<body>
  <div class="container">
    <h1><span class="icon">⚙️</span> Chess Puzzle Extension Settings</h1>
    
    <div class="info-bar">
      This extension presents chess puzzles that increase in difficulty as you use a website. Solve puzzles to gain time, but be careful - mistakes will cost you!
    </div>
    
    <div class="setting">
      <div class="setting-text">
        <h2>Show timer</h2>
        <p>Display a timer for time left on websites</p>
      </div>
      <label class="switch">
        <input type="checkbox" id="showTimer" checked>
        <span class="slider round"></span>
      </label>
    </div>
    
    <div class="setting">
      <div class="setting-text">
        <h2>Global Settings</h2>
        <p>Configure global puzzle and time settings.</p>
      </div>
      <div id="globalSettings" class="global-controls">
        <label>Min ELO: <input type="number" id="minElo" min="500" max="3000"></label>
        <label>Max ELO: <input type="number" id="maxElo" min="500" max="3000"></label>
        <label>Time bonus (seconds): <input type="number" id="timeBonus" min="0" max="60"></label>
        <label>Wrong move penalty (seconds): <input type="number" id="wrongMovePenalty" min="0" max="60"></label>
        <label>Hint penalty (seconds): <input type="number" id="hintPenalty" min="0" max="60"></label>
        <label>Skip penalty (seconds): <input type="number" id="skipPenalty" min="0" max="60"></label>
      </div>
    </div>
    
    <div class="setting">
      <div class="setting-text">
        <h2>Add website</h2>
        <p>Add a new website to the list below</p>
      </div>
      <div class="add-website">
        <input type="text" id="websiteInput" placeholder="Enter website URL">
        <button id="addWebsite">Add Website</button>
      </div>
    </div>
    
    <div class="setting">
      <div class="setting-text">
        <h2>Website Settings</h2>
        <p>Configure session settings for each website.</p>
      </div>
      <ul id="websiteList" class="website-list"></ul>
    </div>
    
    <div class="footer">
      Enjoying the Chess Puzzle Extension? <a href="#">Please leave us a rating and review</a>
    </div>
  </div>
  <script src="settings.js"></script>
</body>
</html>
</file>

<file path="settings/settings.js">
document.addEventListener('DOMContentLoaded', loadSettings);
document.getElementById('addWebsite').addEventListener('click', addWebsite);

function loadSettings() {
  chrome.storage.sync.get(['websites', 'showTimer', 'globalSettings'], (data) => {
    if (data.websites) {
      // Filter out invalid entries
      const validWebsites = data.websites.filter(site => 
        site && typeof site === 'object' && site.url && typeof site.url === 'string' && site.url !== 'undefined'
      );
      
      // If we filtered out any invalid entries, update the storage
      if (validWebsites.length !== data.websites.length) {
        chrome.storage.sync.set({websites: validWebsites}, () => {
          console.log('Removed invalid website entries');
        });
      }
      
      updateWebsiteList(validWebsites);
    }
    if (data.showTimer !== undefined) document.getElementById('showTimer').checked = data.showTimer;
    if (data.globalSettings) updateGlobalSettings(data.globalSettings);
    else initializeGlobalSettings();
  });
}

function initializeGlobalSettings() {
  const defaultGlobalSettings = {
    minElo: 800,
    maxElo: 2000,
    timeBonus: 2,
    wrongMovePenalty: 1,
    hintPenalty: 1,
    skipPenalty: 2
  };
  chrome.storage.sync.set({globalSettings: defaultGlobalSettings}, () => {
    updateGlobalSettings(defaultGlobalSettings);
  });
}

function updateGlobalSettings(settings) {
  Object.keys(settings).forEach(key => {
    const element = document.getElementById(key);
    if (element) element.value = settings[key];
  });
}

function addWebsite() {
  const input = document.getElementById('websiteInput');
  const website = input.value.trim();
  if (website) {
    chrome.storage.sync.get({websites: []}, (data) => {
      if (!data.websites.some(site => site.url === website)) {
        data.websites.push({
          url: website,
          sessions: 3,
          timePerSession: 30
        });
        chrome.storage.sync.set({websites: data.websites}, () => {
          updateWebsiteList(data.websites);
          input.value = '';
        });
      } else {
        alert('This website is already in the list.');
      }
    });
  }
}

function updateWebsiteList(websites) {
  const list = document.getElementById('websiteList');
  list.innerHTML = '';
  websites.forEach(site => {
    const li = document.createElement('li');
    li.innerHTML = `
      <h3>${site.url}</h3>
      <div class="website-controls">
        <label>Sessions per day: <input type="number" class="sessions" value="${site.sessions}" min="1" max="10"></label>
        <label> per session: <input type="number" class="timePerSession" value="${site.timePerSession}" min="1" max="120"></label>
        <button class="remove-website" data-site="${site.url}">Remove</button>
      </div>
    `;
    list.appendChild(li);
  });
  
  // Add event listeners to remove buttons and input fields
  document.querySelectorAll('.remove-website').forEach(btn => {
    btn.addEventListener('click', function() {
      removeWebsite(this.getAttribute('data-site'));
    });
  });

  document.querySelectorAll('.website-controls input').forEach(input => {
    input.addEventListener('change', function() {
      updateWebsiteSettings(this);
    });
  });
}

function removeWebsite(siteUrl) {
  chrome.storage.sync.get({websites: []}, (data) => {
    const updatedWebsites = data.websites.filter(site => site.url !== siteUrl);
    chrome.storage.sync.set({websites: updatedWebsites}, () => {
      updateWebsiteList(updatedWebsites);
    });
  });
}

function updateWebsiteSettings(input) {
  const li = input.closest('li');
  const siteUrl = li.querySelector('h3').textContent;
  const newValue = parseInt(input.value);
  const settingName = input.className;

  chrome.storage.sync.get({websites: []}, (data) => {
    const updatedWebsites = data.websites.map(site => {
      if (site.url === siteUrl) {
        site[settingName] = newValue;
      }
      return site;
    });
    chrome.storage.sync.set({websites: updatedWebsites});
  });
}

// Save showTimer setting when toggled
document.getElementById('showTimer').addEventListener('change', function() {
  chrome.storage.sync.set({showTimer: this.checked});
});

// Save global settings when changed
document.querySelectorAll('#globalSettings input').forEach(input => {
  input.addEventListener('change', function() {
    saveGlobalSettings();
  });
});

function saveGlobalSettings() {
  const globalSettings = {
    minElo: parseInt(document.getElementById('minElo').value),
    maxElo: parseInt(document.getElementById('maxElo').value),
    timeBonus: parseInt(document.getElementById('timeBonus').value),
    wrongMovePenalty: parseInt(document.getElementById('wrongMovePenalty').value),
    hintPenalty: parseInt(document.getElementById('hintPenalty').value),
    skipPenalty: parseInt(document.getElementById('skipPenalty').value)
  };
  chrome.storage.sync.set({globalSettings});
}
</file>

</repository_files>
